// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package application

import (
	"fmt"

	"github.com/pkg/errors"

	downloader "github.com/elastic/fleet/x-pack/pkg/artifact/download/http"
	"github.com/elastic/fleet/x-pack/pkg/artifact/install"
	"github.com/elastic/fleet/x-pack/pkg/bus"
	"github.com/elastic/fleet/x-pack/pkg/bus/topic"
	"github.com/elastic/fleet/x-pack/pkg/config"
	"github.com/elastic/fleet/x-pack/pkg/core/logger"
	"github.com/elastic/fleet/x-pack/pkg/core/plugin/clientvault"
	"github.com/elastic/fleet/x-pack/pkg/core/plugin/operation"
	"github.com/elastic/fleet/x-pack/pkg/core/plugin/process/watcher"
	rconfig "github.com/elastic/fleet/x-pack/pkg/core/remoteconfig/grpc"
	"github.com/elastic/fleet/x-pack/pkg/stateresolver"
)

// Errors generated by the application.
var (
	ErrManagedIsNotImplemented = errors.New("managed mode is not implemented in the agent")
)

// Application is the application interface implemented by the different running mode.
type Application interface {
	Start() error
	Stop() error
}

// New creates a new application, the type of application is dependant on the configured settings.
// if a management option exists in the YAML we assume that the application will retrieve his
// configuration from Kibana.  If no management is found we assume that the application read the
// configuration locally. In both cases we pass the raw configuration to the application for more
// validations.
func New(log *logger.Logger, pathConfigFile string) (Application, error) {
	// Load configuration from disk to understand in which mode of operation
	// we must start the agent, the mode of operation cannot be changed without restarting the
	// agent.
	config, err := config.LoadYAML(pathConfigFile)
	if err != nil {
		return nil, err
	}

	log.Info("Finding execution mode")
	c := struct {
		Management *string `yaml:"management"`
	}{}

	if err := config.Unpack(&c); err != nil {
		return nil, err
	}

	eventBus, err := bus.NewEventBus(log)
	if err != nil {
		return nil, err
	}

	resolver, err := newStateResolver(log, eventBus)
	if err != nil {
		return nil, err
	}

	operator, err := newOperator(log, eventBus, config)
	if err != nil {
		return nil, err
	}

	if c.Management == nil {
		log.Info("Agent is run in local mode")
		return newLocal(log, pathConfigFile, operator, resolver, eventBus)
	}

	log.Info("Agent is run in remotely managed mode")
	return newManaged(log, config, operator, resolver, eventBus)
}

// Local define an early local agent.
type Local struct {
	log          *logger.Logger
	configReader *configReader
	bus          bus.Bus
	configSource *onlyOnceConfigSource
	operator     *operation.Operator
	resolver     *stateresolver.StateResolver
}

// newLocal return a agent managed by local configuration.
func newLocal(log *logger.Logger, pathConfigFile string, operator *operation.Operator, resolver *stateresolver.StateResolver, eventBus *bus.EventBus) (*Local, error) {
	var err error
	if log == nil {
		log, err = logger.New()
		if err != nil {
			return nil, err
		}
	}
	configReader := newConfigReader(log, pathConfigFile)

	if err := eventBus.CreateTopic(topic.Configurations); err != nil && err != bus.ErrTopicExist {
		return nil, err
	}

	configSource := newOnlyOnceConfigSource(
		log,
		configReader,
		eventBus,
		topic.Configurations,
	)

	return &Local{
		log:          log,
		configReader: configReader,
		bus:          eventBus,
		configSource: configSource,
		resolver:     resolver,
	}, nil
}

// Start starts a local agent.
func (l *Local) Start() error {
	l.log.Info("Agent is starting")
	defer l.log.Info("Agent is stopped")

	l.bus.Start()
	if err := l.configSource.start(); err != nil {
		return err
	}

	return nil
}

// Stop stops a local agent.
func (l *Local) Stop() error {
	l.bus.Stop()
	return nil
}

// Managed application, when the application is run in managed mode, most of the configuration are
// coming from the Fleet App.
type Managed struct {
	log *logger.Logger
}

func newManaged(log *logger.Logger, rawConfig *config.Config, operator *operation.Operator, resolver *stateresolver.StateResolver, eventBus *bus.EventBus) (*Managed, error) {
	return nil, ErrManagedIsNotImplemented
}

// Start starts a managed agent.
func (m *Managed) Start() error {
	return ErrManagedIsNotImplemented
}

// Stop stops a managed agent.
func (m *Managed) Stop() error {
	return ErrManagedIsNotImplemented
}

func newOperator(log *logger.Logger, eventBus *bus.EventBus, config *config.Config) (*operation.Operator, error) {
	w := watcher.NewProcessWatcher(log)

	operatorConfig := &operation.Config{}
	if err := config.Unpack(&operatorConfig); err != nil {
		return nil, err
	} 

	factory := rconfig.NewConnFactory(operatorConfig.RetryConfig.Delay, operatorConfig.RetryConfig.MaxDelay)
	cv, err := clientvault.NewClientVault(factory)
	if err != nil {
		return nil, err
	}

	fetcher := downloader.NewDownloader(operatorConfig.DownloadConfig)
	installer, err := install.NewInstaller(operatorConfig.DownloadConfig)
	if err != nil {
		return nil, errors.Wrap(err, "initiating installer")
	}

	return operation.NewOperator(log, cv, w, config, eventBus, true, fetcher, installer, topic.StateChanges)
}

func newStateResolver(log *logger.Logger, eventBus *bus.EventBus) (*stateresolver.StateResolver, error) {
	err := eventBus.CreateTopic(topic.StateChanges)
	if err != nil && err != bus.ErrTopicExist {
		return nil, errors.Wrap(err, fmt.Sprintf("creating topic '%v' for operator", topic.StateChanges))
	}

	err = eventBus.CreateTopic(topic.Configurations)
	if err != nil && err != bus.ErrTopicExist {
		return nil, errors.Wrap(err, fmt.Sprintf("creating topic '%v' for operator", topic.Configurations))
	}

	return stateresolver.NewCustomStateResolver(log, eventBus, topic.Configurations, topic.StateChanges)
}
