#!/usr/bin/env groovy

@Library('apm@feature/2.0-beats') _

pipeline {
  agent { label 'ubuntu-18 && immutable' }
  environment {
    AWS_ACCOUNT_SECRET = 'secret/observability-team/ci/elastic-observability-aws-account-auth'
    BASE_DIR = 'src/github.com/elastic/beats'
    DOCKERELASTIC_SECRET = 'secret/observability-team/ci/docker-registry/prod'
    DOCKER_COMPOSE_VERSION = "1.21.0"
    DOCKER_REGISTRY = 'docker.elastic.co'
    GOX_FLAGS = "-arch amd64"
    JOB_GCS_BUCKET = 'beats-ci-temp'
    JOB_GCS_CREDENTIALS = 'beats-ci-gcs-plugin'
    PIPELINE_LOG_LEVEL = 'INFO'
    OSS_MODULE_PATTERN = '^[a-z0-9]+beat\\/module\\/([^\\/]+)\\/.*'
    RUNBLD_DISABLE_NOTIFICATIONS = 'true'
    TERRAFORM_VERSION = "0.12.24"
    XPACK_MODULE_PATTERN = '^x-pack\\/[a-z0-9]+beat\\/module\\/([^\\/]+)\\/.*'
  }
  options {
    timeout(time: 2, unit: 'HOURS')
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    quietPeriod(10)
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
  }
  triggers {
    issueCommentTrigger('(?i)(.*(?:jenkins\\W+)?run\\W+(?:the\\W+)?tests(?:\\W+please)?.*|^/test\\W+.*$)')
  }
  parameters {
    booleanParam(name: 'allCloudTests', defaultValue: false, description: 'Run all cloud integration tests.')
    booleanParam(name: 'awsCloudTests', defaultValue: false, description: 'Run AWS cloud integration tests.')
    string(name: 'awsRegion', defaultValue: 'eu-central-1', description: 'Default AWS region to use for testing.')
    booleanParam(name: 'runAllStages', defaultValue: false, description: 'Allow to run all stages.')
    booleanParam(name: 'macosTest', defaultValue: false, description: 'Allow macOS stages.')
    booleanParam(name: 'windowsTest', defaultValue: true, description: 'Allow Windows stages.')
    booleanParam(name: 'debug', defaultValue: false, description: 'Allow debug logging for Jenkins steps')
  }
  stages {
    stage('Checkout') {
      options { skipDefaultCheckout() }
      steps {
        pipelineManager([ cancelPreviousRunningBuilds: [ when: 'PR' ] ])
        deleteDir()
        gitCheckout(basedir: "${BASE_DIR}", githubNotifyFirstTimeContributor: true)
        stashV2(name: 'source', bucket: "${JOB_GCS_BUCKET}", credentialsId: "${JOB_GCS_CREDENTIALS}")
        dir("${BASE_DIR}"){
          // Skip all the stages except docs for PR's with asciidoc and md changes only
          setEnvVar('ONLY_DOCS', isGitRegionMatch(patterns: [ '.*\\.(asciidoc|md)' ], shouldMatchAll: true).toString())
          setEnvVar('GO_VERSION', readFile(".go-version").trim())
          withEnv(["HOME=${env.WORKSPACE}"]) {
            retryWithSleep(retries: 2, seconds: 5){ sh(label: "Install Go ${env.GO_VERSION}", script: '.ci/scripts/install-go.sh') }
          }
        }
      }
    }
    stage('Lint'){
      options { skipDefaultCheckout() }
      environment {
        GOFLAGS = '-mod=readonly'
      }
      when {
        anyOf {
          not { changeRequest() }                           // If no PR
          allOf {                                           // If PR and no docs changes
            expression { return env.ONLY_DOCS == "false" }
            changeRequest()
          }
          expression { return params.runAllStages }         // If UI forced
        }
      }
      steps {
        echo 'linting'
      }
    }
    stage('Build&Test') {
      options { skipDefaultCheckout() }
      steps {
        deleteDir()
        unstashV2(name: 'source', bucket: "${JOB_GCS_BUCKET}", credentialsId: "${JOB_GCS_CREDENTIALS}")
        dir("${BASE_DIR}"){
          script {
            def mapParallelTasks = [:]
            def content = readYaml(file: 'Jenkinsfile.yml')
            content['projects'].each { projectName ->
              generateStages(project: projectName, changeset: content['changeset']).each { k,v ->
                mapParallelTasks["${k}"] = v
              }
            }
            parallel(mapParallelTasks)
          }
        }
      }
      post {
        always {
          echo 'TODO: save markdown files for the record'
        }
      }
    }
  }
  post {
    // TODO: Support runbld
    cleanup {
      notifyBuildResult(prComment: true)
    }
  }
}

def generateStages(Map args = [:]) {
  def projectName = args.project
  def changeset = args.changeset
  def mapParallelStages = [:]
  def fileName = "${projectName}/Jenkinsfile.yml"
  if (fileExists(fileName)) {
    def content = readYaml(file: fileName)
    if (beatsWhen(project: projectName, content: content?.when, changeset: changeset)) {
      mapParallelStages = beatsStages(project: projectName, content: content, changeset: changeset, function: runCommand())
    }
  } else {
    log(level: 'WARN', text: "${fileName} file does not exist. Please review the top-level Jenkinsfile.yml")
  }
  return mapParallelStages
}

def runCommand(Map args = [:]) {
  if(args?.containsKey('make')) {
    makeTarget(args)
  } else {
    mageTarget(args)
  }
}

def makeTarget(Map args = [:]) {
  def context = args.context
  def target = args.target
  def directory = args.get('directory', '')
  def clean = args.get('clean', true)
  def withModule = args.get('withModule', false)
  def directoryFlag = directory.trim() ? "-C ${directory}" : ''
  withGithubNotify(context: "${context}") {
    withBeatsEnv(archive: true, withModule: withModule, directory: directory) {
      sh(label: "Make ${target}", script: "make ${directoryFlag} ${target}")
    }
  }
}

def mageTarget(Map args = [:]) {
  def context = args.context
  def directory = args.directory
  def target = args.target
  def withModule = args.get('withModule', false)
  withGithubNotify(context: "${context}") {
    withBeatsEnv(archive: true, withModule: withModule, directory: directory) {
      dir(directory) {
        cmd(label: "Mage ${target}", script: "mage ${verboseFlag} ${target}")
      }
    }
  }
}

def withBeatsEnv(Map args = [:], Closure body) {
  def archive = args.get('archive', true)
  def withModule = args.get('withModule', false)
  def directory = args.get('directory', '')
  def modulePattern
  if (withModule) {
    modulePattern = getModulePattern(directory)
  }
  def goRoot, path, magefile, pythonEnv, testResults, artifacts

  if(isUnix()) {
    goRoot = "${env.WORKSPACE}/.gvm/versions/go${GO_VERSION}.${nodeOS()}.amd64"
    path = "${env.WORKSPACE}/bin:${goRoot}/bin:${env.PATH}"
    magefile = "${WORKSPACE}/.magefile"
    pythonEnv = "${WORKSPACE}/python-env"
    testResults = '**/build/TEST*.xml'
    artifacts = '**/build/TEST*.out'
  } else {
    def chocoPath = 'C:\\ProgramData\\chocolatey\\bin'
    def chocoPython3Path = 'C:\\Python38;C:\\Python38\\Scripts'
    goRoot = "${env.USERPROFILE}\\.gvm\\versions\\go${GO_VERSION}.windows.amd64"
    path = "${env.WORKSPACE}\\bin;${goRoot}\\bin;${chocoPath};${chocoPython3Path};${env.PATH}"
    magefile = "${env.WORKSPACE}\\.magefile"
    testResults = "**\\build\\TEST*.xml"
    artifacts = "**\\build\\TEST*.out"
  }

  deleteDir()
  unstashV2(name: 'source', bucket: "${JOB_GCS_BUCKET}", credentialsId: "${JOB_GCS_CREDENTIALS}")
  // NOTE: This is required to run after the unstash
  def module = withModule ? getCommonModuleInTheChangeSet(modulePattern, directory) : ''
  withEnv([
    "HOME=${env.WORKSPACE}",
    "GOPATH=${env.WORKSPACE}",
    "GOROOT=${goRoot}",
    "PATH=${path}",
    "MAGEFILE_CACHE=${magefile}",
    "TEST_COVERAGE=true",
    "RACE_DETECTOR=true",
    "PYTHON_ENV=${pythonEnv}",
    "TEST_TAGS=${env.TEST_TAGS},oracle",
    "DOCKER_PULL=0",
    "MODULE=${module}"
  ]) {
    if(isDockerInstalled()){
      dockerLogin(secret: "${DOCKERELASTIC_SECRET}", registry: "${DOCKER_REGISTRY}")
    }
    dir("${env.BASE_DIR}") {
      installTools()

      if(isUnix()) {
        // TODO (2020-04-07): This is a work-around to fix the Beat generator tests.
        // See https://github.com/elastic/beats/issues/17787.
        sh(label: 'check git config', script: '''
          if [ -z "$(git config --get user.email)" ]; then
            git config user.email "beatsmachine@users.noreply.github.com"
            git config user.name "beatsmachine"
          fi''')
      }
      try {
        body()
      } finally {
        if (archive) {
          //archiveTestOutput(testResults: testResults, artifacts: artifacts)
        }
      }
    }
  }
}

def installTools() {
  def i = 2 // Number of retries
  if(isUnix()) {
    retryWithSleep(retries: i, seconds: 5, backoff: true){ sh(label: "Install Go/Mage/Python/Docker/Terraform ${GO_VERSION}", script: ".ci/scripts/install-tools.bat") }
  } else {
    retryWithSleep(retries: i, seconds: 5, backoff: true){ bat(label: "Install Go/Mage/Python ${GO_VERSION}", script: ".ci/scripts/install-tools.bat") }
  }
}

