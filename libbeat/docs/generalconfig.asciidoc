//////////////////////////////////////////////////////////////////////////
//// This content is shared by all Elastic Beats. Make sure you keep the
//// descriptions here generic enough to work for all Beats that include
//// this file. When using cross references, make sure that the cross
//// references resolve correctly for any files that include this one.
//// Use the appropriate variables defined in the index.asciidoc file to
//// resolve Beat names: beatname_uc and beatname_lc.
//// Use the following include to pull this content into a doc file:
//// include::../../libbeat/docs/generalconfig.asciidoc[]
//// Make sure this content appears below a level 2 heading.
//////////////////////////////////////////////////////////////////////////

[float]
[[configuration-general]]
=== General configuration options

These options are supported by all Elastic Beats. Because they are common
options, they are not namespaced.

Here is an example configuration:

[source,yaml]
------------------------------------------------------------------------------
name: "my-shipper"
tags: ["service-X", "web-tier"]
------------------------------------------------------------------------------

[float]
==== `name`

The name of the Beat. If this option is empty, the `hostname` of the server is
used. The name is included as the `beat.name` field in each published transaction. You can
use the name to group all transactions sent by a single Beat.

Example:

[source,yaml]
------------------------------------------------------------------------------
name: "my-shipper"
------------------------------------------------------------------------------

[float]
==== `tags`

A list of tags that the Beat includes in the `tags` field of each published
transaction. Tags make it easy to group servers by different logical properties.
For example, if you have a cluster of web servers, you can add the "webservers"
tag to the Beat on each server, and then use filters and queries in the Kibana
web interface to get visualisations for the whole group of servers.

Example:

[source,yaml]
--------------------------------------------------------------------------------
tags: ["my-service", "hardware", "test"]
--------------------------------------------------------------------------------

[float]
[[libbeat-configuration-fields]]
==== `fields`

Optional fields that you can specify to add additional information to the
output. Fields can be scalar values, arrays, dictionaries, or any nested
combination of these. By default, the fields that you specify here will be
grouped under a `fields` sub-dictionary in the output document. To store the
custom fields as top-level fields, set the `fields_under_root` option to true.

Example:

[source,yaml]
------------------------------------------------------------------------------
fields: {project: "myproject", instance-id: "574734885120952459"}
------------------------------------------------------------------------------

[float]
==== `fields_under_root`

If this option is set to true, the custom <<libbeat-configuration-fields,fields>> are
stored as top-level fields in the output document instead of being grouped under
a `fields` sub-dictionary. If the custom field names conflict with other field
names, then the custom fields overwrite the other fields.

Example:

[source,yaml]
------------------------------------------------------------------------------
fields_under_root: true
fields:
  instance_id: i-10a64379
  region: us-east-1
------------------------------------------------------------------------------

[float]
==== `processors`

A list of processors to apply to the data generated by the beat.

See <<filtering-and-enhancing-data>> for information about specifying
processors in your config.

[float]
==== `max_procs`

Sets the maximum number of CPUs that can be executing simultaneously. The
default is the number of logical CPUs available in the system.

[float]
[[configuration-internal-queue]]
=== Configure the internal queue

The `queue` namespace configures the queue type to be used.

The Elastic Beats employ an internal queue for events to be published. The
queue is responsible for buffering and combining events into batches, which can
be consumed by the outputs. The outputs will use bulk operations to send a
batch of events in one transaction.


Example configuration:

[source,yaml]
------------------------------------------------------------------------------
queue.mem:
  events: 4096
------------------------------------------------------------------------------

==== Configure the Memory Qeueue
[[configuration-internal-queue-memory]]

The memory queue keeps all events in memory. By default no flush interval is
configured. All events published to this queue will be directly consumed by the
outputs. An output will consume up to the outputs `bulk_max_size` events at once.

Only after an event is dropped or acknowledged by the output, a new slot will
be available in the queue.

By setting `flush.min_events` and `flush.timeout`, spooling in the queue is
enforced. In this case the output has to wait for a minimal number of events
to be available.

This sample configuration forwards events to the output if 512 events are
available or the oldest available event is already waiting for 5s in the queue:

[source,yaml]
------------------------------------------------------------------------------
queue.mem:
  events: 4096
  flush.min_events: 512
  flush.timeout: 5s
------------------------------------------------------------------------------

===== `events`

Number of events the queue can store. 

The default value is 4096 events.

===== `flush.min_events`

Minimum number of events required for publishing. If this value is set to 0, the
output can start publishing events without additional waiting times. Otherwise
the output has to wait for more events to become available.

The default value is 0.

===== `flush.timeout`

Maximum wait time for `flush.min_events` to be fulfilled. If set to 0s, events
will be immediately available for consumption.

The default values is 0s.

