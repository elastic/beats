package match

import (
	"regexp"
	"regexp/syntax"
	"strings"
)

type Match struct {
	stringMatcher
}

type stringMatcher interface {
	// matchString tries to find a matching substring. If matched is false,
	// the matcher didn't match. If matched is true, rest contains the yet
	// unmatched substring which can be used for further matching (e.g. when
	// concatenating matches)
	MatchString(s string) (matched bool)
}

type substringMatcher struct {
	s string
}

type prefixMatcher struct {
	s string
}

type emptyStringMatcher struct{}

type emptyWhiteStringMatcher struct{}

func MustCompile(pattern string) Match {
	m, err := Compile(pattern)
	if err != nil {
		panic(err)
	}
	return m
}

func Compile(pattern string) (Match, error) {
	regex, err := syntax.Parse(pattern, syntax.Perl)
	if err != nil {
		return Match{}, err
	}

	regex = optimize(regex).Simplify()
	return compile(regex)
}

func compile(r *syntax.Regexp) (Match, error) {
	switch {
	case r.Op == syntax.OpLiteral:
		s := string(r.Rune)
		return Match{&substringMatcher{s}}, nil

	case isPrefixLiteral(r):
		s := string(r.Sub[0].Rune)
		return Match{&prefixMatcher{s}}, nil

	case isEmptyText(r):
		var m *emptyStringMatcher
		return Match{m}, nil

	case isEmptyTextWithWhitespace(r):
		var m *emptyWhiteStringMatcher
		return Match{m}, nil

	default:
		r, err := regexp.Compile(r.String())
		if err != nil {
			return Match{}, err
		}
		return Match{r}, nil
	}
}

func (m *substringMatcher) MatchString(s string) bool {
	idx := strings.Index(s, m.s)
	if idx < 0 {
		return false
	}
	return true
}

func (m *prefixMatcher) MatchString(s string) bool {
	if !strings.HasPrefix(s, m.s) {
		return false
	}
	return true
}

func (m *emptyStringMatcher) MatchString(s string) bool {
	return len(s) == 0
}

func (m *emptyWhiteStringMatcher) MatchString(s string) bool {
	for _, r := range s {
		if !(r == ' ' || ('\t' <= r && r <= '\n') || ('\f' <= r && r <= 'r')) {
			return false
		}
	}
	return true
}

type trans func(*syntax.Regexp) (bool, *syntax.Regexp)

var transformations = []trans{
	simplify,
	uncapture,
	trimLeft,
	trimRight,
	unconcat,
}

// optimize runs minimal regular expression optimizations
// until fix-point.
func optimize(r *syntax.Regexp) *syntax.Regexp {
	for {
		changed := false
		for _, t := range transformations {
			var upd bool
			upd, r = t(r)
			changed = changed || upd
		}

		if changed == false {
			return r
		}
	}
}

// Simplify regular expression by stdlib.
func simplify(r *syntax.Regexp) (bool, *syntax.Regexp) {
	return false, r.Simplify()
}

// uncapture optimizes regular expression by removing capture groups from
// regular expression potentially allocating memory when executed.
func uncapture(r *syntax.Regexp) (bool, *syntax.Regexp) {
	if r.Op == syntax.OpCapture {
		// try to uncapture
		if len(r.Sub) == 1 {
			_, sub := uncapture(r.Sub[0])
			return true, sub
		}

		tmp := *r
		tmp.Op = syntax.OpConcat
		r = &tmp
	}

	sub := make([]*syntax.Regexp, len(r.Sub))
	modified := false
	for i := range r.Sub {
		var m bool
		m, sub[i] = uncapture(r.Sub[i])
		modified = modified || m
	}

	if !modified {
		return false, r
	}

	tmp := *r
	tmp.Sub = sub
	return true, &tmp
}

// trimLeft removes not required '.*' from beginning of regular expressions.
func trimLeft(r *syntax.Regexp) (bool, *syntax.Regexp) {
	switch r.Op {
	case syntax.OpStar:
		if isdotStar(r) {
			return true, &syntax.Regexp{
				Op:    syntax.OpEmptyMatch,
				Flags: r.Flags,
			}
		}

	case syntax.OpConcat:
		if len(r.Sub) == 0 || !isdotStar(r.Sub[0]) {
			break
		}

		tmp := *r
		tmp.Sub = tmp.Sub[1:]
		return true, &tmp
	}

	return false, r
}

// trimLeft removes not required '.*' from end of regular expressions.
func trimRight(r *syntax.Regexp) (bool, *syntax.Regexp) {
	switch r.Op {
	case syntax.OpStar:
		if isdotStar(r) {
			return true, &syntax.Regexp{
				Op:    syntax.OpEmptyMatch,
				Flags: r.Flags,
			}
		}

	case syntax.OpConcat:
		i := len(r.Sub) - 1
		if len(r.Sub) == 0 || !isdotStar(r.Sub[i]) {
			break
		}

		tmp := *r
		tmp.Sub = tmp.Sub[0:i]
		return true, &tmp
	}

	return false, r
}

// unconcat removes intermediate regular expression concatenations generated by
// parser if concatenation contains only 1 element. Removal of object from
// parse-tree can enable other optimization to fire.
func unconcat(r *syntax.Regexp) (bool, *syntax.Regexp) {
	if r.Op != syntax.OpConcat || len(r.Sub) > 1 {
		return false, r
	}

	if len(r.Sub) == 0 {
		return true, &syntax.Regexp{
			Op:    syntax.OpEmptyMatch,
			Flags: r.Flags,
		}
	}

	if len(r.Sub) == 1 {
		return true, r.Sub[0]
	}

	return false, r
}

// isdotStar checks the term being `.*`.
func isdotStar(r *syntax.Regexp) bool {
	return r.Op == syntax.OpStar &&
		len(r.Sub) == 1 &&
		r.Sub[0].Op == syntax.OpAnyCharNotNL
}

// isPrefixLiteral checks regular expression being literal checking string
// starting with literal pattern (like '^PATTERN')
func isPrefixLiteral(r *syntax.Regexp) bool {
	return r.Op == syntax.OpConcat &&
		len(r.Sub) == 2 &&
		r.Sub[0].Op == syntax.OpBeginText &&
		r.Sub[1].Op == syntax.OpLiteral
}

func isEmptyText(r *syntax.Regexp) bool {
	return r.Op == syntax.OpConcat &&
		len(r.Sub) == 2 &&
		r.Sub[0].Op == syntax.OpBeginText &&
		r.Sub[1].Op == syntax.OpEndText
}

func isEmptyTextWithWhitespace(r *syntax.Regexp) bool {
	return r.Op == syntax.OpConcat &&
		len(r.Sub) == 3 &&
		r.Sub[0].Op == syntax.OpBeginText &&
		r.Sub[1].Op == syntax.OpStar &&
		r.Sub[1].Sub[0].Op == syntax.OpCharClass &&
		r.Sub[1].Sub[0].String() == `[\t-\n\f-\r ]` &&
		r.Sub[2].Op == syntax.OpEndText
}
