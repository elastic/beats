// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//go:build integration

package integration

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/brianvoe/gofakeit"
)

// WriteLogFile writes count lines to path
// Each line contains the current time (RFC3339) and a counter
// Prefix is added instead of current time if it exists
func WriteLogFile(t *testing.T, path string, count int, append bool, prefix ...string) {
	var file *os.File
	var err error
	if !append {
		file, err = os.Create(path)
		if err != nil {
			t.Fatalf("could not create file '%s': %s", path, err)
		}
	} else {
		file, err = os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666)
		if err != nil {
			t.Fatalf("could not open or create file: '%s': %s", path, err)
		}
	}

	defer func() {
		if err := file.Close(); err != nil {
			t.Fatalf("could not close file: %s", err)
		}
	}()
	defer func() {
		if err := file.Sync(); err != nil {
			t.Fatalf("could not sync file: %s", err)
		}
	}()

	var now string
	if len(prefix) == 0 {
		// If the length is different, e.g when there is no offset from UTC.
		// add some padding so the length is predictable
		now = time.Now().Format(time.RFC3339)
		if len(now) != len(time.RFC3339) {
			paddingNeeded := len(time.RFC3339) - len(now)
			for range paddingNeeded {
				now += "-"
			}
		}
	} else {
		now = strings.Join(prefix, "")
	}

	for i := range count {
		if _, err := fmt.Fprintf(file, "%s           %13d\n", now, i); err != nil {
			t.Fatalf("could not write line %d to file: %s", count+1, err)
		}
	}
}

// WriteNLogFiles generates nFiles with nLines in each. The lines are a
// random phrase generated by Gofakeit. Files are generated into a `logs`
// folder created in tempDir and the names follow the format "%06d.log".
// The returned value is the folder containing the log files.
func WriteNLogFiles(t *testing.T, tempDir string, nFiles, nLines int) string {
	basePath := filepath.Join(tempDir, "logs")
	if err := os.MkdirAll(basePath, 0777); err != nil {
		t.Fatalf("cannot create folder to store logs: %s", err)
	}

	for fCount := range nFiles {
		path := filepath.Join(basePath, fmt.Sprintf("%06d.log", fCount))
		f, err := os.Create(path)
		if err != nil {
			t.Errorf("cannot create file: %s", err)
		}
		for range nLines {
			_, _ = f.WriteString(gofakeit.HackerPhrase() + "\n")
		}
		if err := f.Sync(); err != nil {
			t.Errorf("cannot sync %q: %s", path, err)
		}
		if err := f.Close(); err != nil {
			t.Errorf("cannot close %q: %s", path, err)
		}
	}

	return basePath
}

// WriteAppendingLogFile generates a log file by appending the current
// time to it every second. The files are flushed after every write.
func WriteAppendingLogFile(t *testing.T, fullPath string) {
	t.Helper()
	f, err := os.Create(fullPath)
	if err != nil {
		t.Fatalf("could not create file '%s: %s", fullPath, err)
	}

	go func() {
		t.Helper()
		ticker := time.NewTicker(time.Second)
		t.Cleanup(ticker.Stop)

		done := make(chan struct{})
		t.Cleanup(func() { close(done) })

		defer func() {
			if err := f.Close(); err != nil {
				t.Errorf("could not close log file '%s': %s", fullPath, err)
			}
		}()

		for {
			select {
			case <-done:
				return
			case now := <-ticker.C:
				_, err := fmt.Fprintln(f, now.Format(time.RFC3339))
				if err != nil {
					// The Go compiler does not allow me to call t.Fatalf from a non-test
					// goroutine, so just log it instead
					t.Errorf("could not write data to log file '%s': %s", fullPath, err)
					return
				}
				// make sure log lines are synced as quickly as possible
				if err := f.Sync(); err != nil {
					t.Errorf("could not sync file '%s': %s", fullPath, err)
				}
			}
		}
	}()
}
