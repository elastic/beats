// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package memlog

import (
	"math"
	"os"
	"path/filepath"
	"sync"

	"github.com/elastic/beats/v7/libbeat/registry/backend"
)

// Registry provides access to the memlog stores.
// Each store will have it's own directory with data files and transaction log.
type Registry struct {
	mu     sync.Mutex
	active bool

	// root     string
	// fileMode os.FileMode
	settings Settings

	wg sync.WaitGroup
}

// Settings configures a new Registry.
type Settings struct {
	// Registry root directory. Stores will be single sub-directories.
	Root string

	// FileMode is used to configure the file mode for new files generated by the regisry.
	// File mode 0600 will be used if this field is not set.
	FileMode os.FileMode

	// BufferSize configures the IO buffer size when accessing the underlying storage files.
	// Defaults to 4096 if not set.
	BufferSize uint

	// Checkpoint predicates is used to check when the registry file should run a checkpoint operation.
	// On checkpoint a new snapshot of the current in memory state is written to
	// a new data file and the transaction log is reset.
	// Checkpoint must return true, in order to trigger a new snapshot.
	// Defaults to CheckpointRatio(2, 10).
	Checkpoint func(pairs, logs uint) bool
}

const defaultFileMode os.FileMode = 0600
const defaultBufferSize = 4096

var defaultCheckpoint = CheckpointRatio(2.0, 10.0)

// New creates a new Registry.
func New(settings Settings) (*Registry, error) {
	if settings.FileMode == 0 {
		settings.FileMode = defaultFileMode
	}
	if settings.Checkpoint == nil {
		settings.Checkpoint = defaultCheckpoint
	}
	if settings.BufferSize == 0 {
		settings.BufferSize = defaultBufferSize
	}

	return &Registry{
		active:   true,
		settings: settings,
	}, nil
}

// Access creates or opens a new store. A new sub-directory for the store if
// created, if the store does not exist.
// Returns an error is any file access fails.
func (r *Registry) Access(name string) (backend.Store, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if !r.active {
		return nil, errRegClosed
	}

	home := filepath.Join(r.settings.Root, name)
	fileMode := r.settings.FileMode
	bufSz := r.settings.BufferSize
	store, err := newStore(home, fileMode, bufSz)
	if err != nil {
		return nil, err
	}

	store.predCheckpoint = r.settings.Checkpoint
	return store, nil
}

// Close closes the registry. No new store can be accessed during close.
// Close blocks until all stores have been closed.
func (r *Registry) Close() error {
	r.mu.Lock()
	r.active = false
	r.mu.Unlock()

	// block until all stores have been closed
	r.wg.Wait()
	return nil
}

// CheckpointRatio compares the number of log entries with the total number of
// key-value pairs in the store.
// CheckpointRatio returns true `#log entries > factor * #pairs`,
// with factor = min(minFactor, max(maxFactor, 1 + 0.5 * log_2(#pairs)))
//
// Idea: The bigger the registry file, the less we want to run expensive checkpoints
//
// x      = number of registry entries
// limit  = number of transaction log entries until next checkpoint
// factor = ratio of registry file size and transaction log entries
//          until checkpointing will be enforced. The bigger the registry,
//          the less we want to execute a checkpoint -> factor should be bigger.
//
//      x      limit    factor
//      1         1        1       // always checkpoint (totalEntries > 2)
//     10        27      2.66
//    100       432      4.32
//   1000      5983      5.98
//  10000     76439      7.64
// 100000    930482      9.3
func CheckpointRatio(minFactor, maxFactor float64) func(uint, uint) bool {
	if maxFactor <= 0 || math.IsNaN(maxFactor) {
		maxFactor = 10.0
	}
	if minFactor <= 1 {
		minFactor = 1
	}
	if minFactor > maxFactor {
		minFactor = maxFactor
	}

	if minFactor == maxFactor {
		return func(pairs, logs uint) bool {
			limit := float64(pairs) * minFactor
			return float64(logs) > limit
		}
	}

	return func(pairs, logs uint) bool {
		if pairs == 0 {
			return true
		}

		if pairs < logs {
			return false
		}

		limit := func(x uint) float64 {
			v := float64(x)
			factor := math.Min(minFactor, math.Max(maxFactor, (1+0.5*math.Log2(v))))
			return v * factor
		}

		return float64(logs) > limit(pairs)
	}
}
