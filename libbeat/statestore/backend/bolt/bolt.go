package bolt

import (
	"encoding/json"
	"errors"
	"os"
	"path/filepath"

	bolt "go.etcd.io/bbolt"

	"github.com/elastic/beats/v7/libbeat/logp"

	"github.com/elastic/beats/v7/libbeat/statestore"
	"github.com/elastic/beats/v7/libbeat/statestore/backend"
)

const (
	dbFileName = "data.db"
)

// Settings configures a new Registry.
type Settings struct {
	// Registry root directory. Stores will be single sub-directories.
	Root string

	// FileMode is used to configure the file mode for new files generated by the
	// regisry.  File mode 0600 will be used if this field is not set.
	FileMode os.FileMode
}

// Registry maintains the access to bolt buckets.
type Registry struct {
	db *bolt.DB
}

func New(log *logp.Logger, settings Settings) (*Registry, error) {
	err := os.MkdirAll(settings.Root, settings.FileMode|0110)
	if err != nil {
		return nil, err
	}

	path := filepath.Join(settings.Root, dbFileName)
	db, err := bolt.Open(path, settings.FileMode, nil)
	if err != nil {
		return nil, err
	}
	return &Registry{
		db: db,
	}, nil
}

// Access creates or opens a new store. A new sub-directory for the store if
// created, if the store does not exist.
// Returns an error is any file access fails.
func (r *Registry) Access(name string) (backend.Store, error) {
	err := r.db.Update(func(tx *bolt.Tx) error {
		_, err := tx.CreateBucketIfNotExists([]byte(name))
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	s := store{
		db:         r.db,
		bucketName: name,
	}
	return &s, nil
}

// Close closes the registry. No new store can be accessed during close.
// Close blocks until all stores have been closed.
func (r *Registry) Close() error {
	// TODO: Check that there is no active stores
	return r.db.Close()
}

type store struct {
	bucketName string
	db         *bolt.DB
}

// Close should close the store and release all used resources.
func (s *store) Close() error {
	return nil
}

// Has checks if the key exists. No error must be returned if the key does
// not exists, but the bool return must be false.
// An error return value must indicate internal errors only. The store is
// assumed to be in a 'bad' but recoverable state if 'Has' fails.
func (s *store) Has(key string) (bool, error) {
	found := false
	err := s.db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(s.bucketName)).Cursor()

		k, _ := c.Seek([]byte(key))
		// Seek may return other key if the exact key doesn't exist
		if string(k) == key {
			found = true
		}

		return nil
	})
	if err != nil {
		return false, nil
	}
	return found, nil
}

// Get decodes the value for the given key into value.
// Besides internal implementation specific errors an error is assumed
// to be returned if the key does not exist or the type of the value
// passed is incompatible to the actual value in the store (decoding error).
func (s *store) Get(key string, value interface{}) error {
	err := s.db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(s.bucketName)).Cursor()

		k, v := c.Seek([]byte(key))
		// Seek may return other key if the exact key doesn't exist
		if string(k) != key {
			return errors.New("key not found")
		}

		return json.Unmarshal(v, value)
	})
	return err
}

// Set inserts or overwrites a key pair in the store.
// The `value` parameters can be assumed to be a struct or a map.  Besides
// internal implementation specific errors, an error should be returned if
// the value given can not be encoded.
func (s *store) Set(key string, value interface{}) error {
	d, err := json.Marshal(value)
	if err != nil {
		return err
	}
	err = s.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(s.bucketName))
		err := b.Put([]byte(key), d)
		return err
	})
	return err
}

// Remove removes and entry from the store.
func (s *store) Remove(key string) error {
	err := s.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(s.bucketName))
		err := b.Delete([]byte(key))
		return err
	})
	return err
}

// Each loops over all key value pairs in the store calling fn for each pair.
// The ValueDecoder is used by fn to optionally decode the value into a
// custom struct or map. The decoder must be executable multiple times, but
// is assumed to be invalidated once fn returns
// The loop shall return if fn returns an error or false.
func (s *store) Each(fn func(string, statestore.ValueDecoder) (bool, error)) error {
	err := s.db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(s.bucketName)).Cursor()

		for k, v := c.First(); k != nil; k, v = c.Next() {
			next, err := fn(string(k), &jsonDecoder{v})
			if err != nil || !next {
				return err
			}
		}

		return nil
	})
	return err
}

type jsonDecoder struct {
	value []byte
}

func (d *jsonDecoder) Decode(to interface{}) error {
	return json.Unmarshal(d.value, to)
}
