[[input-file-log-rotation]]
== Configure logrotation for the input files of {beatname_uc}

Incorrectly configured logrotation can result in either lost log messages or duplicated events when using {beatname_uc} to
forward messages. When you see missing or duplicate events when running the Beat, be sure to check how input files are rotated.

[float]
[[log-rotation-strategies]]
=== Logrotation strategies

[float]
[[log-rotation-truncate]]
===== Truncating the input file

In case of strategies which include copying and truncating the input file is going to result in sending duplicated events.
It happens because {beatname_uc} identifies files by inode and device name. During rotation the already processed lines are
moved to a new file. When {beatname_uc} encounters this new file, it is going to read it from the beginning, as previous state
information (offset, read timestamp) are not found for this inode and device name combination in its state registry.
Furthermore, when the input file is truncated it is possible that the application writing it might added new lines
between the time of the copy and truncation. Those lines get lost. We suggest you avoid using this method for rotating logs.

[float]
[[log-rotation-move]]
===== Moving the input file

When the input file is moved or renamed, {beatname_uc} is able to recognize that the file was already read. After the input is
rotated, a new log file is created, so the application can continue logging. The Beat picks up the new file during the
next scan. As it finds a new file, with new inode and device name, it starts reading it from the beginning.
To avoid missing events from a rotated file, add the rotated files to the input.

[float]
[[log-rotate-example]]
==== Example configurations

In this section we choose to share a sample configuration of logrotate, as it is a popular tool to do log rotation on Linux.

In this example {beatname_uc} reads the logs of a web server. The logs are rotated every day, and the new file is created
with the specified permissions.

[float]
[[log-rotate-example-logrotate]]
===== logrotate.conf

[source,yaml]
-----------------------------------------------------
/var/log/my-server/my-server.log {
    daily
    missingok
    rotate 7
    notifempty
    create 0640 www-data www-data
}
-----------------------------------------------------

{beatname_uc} is configured to read all of the files to make sure it does not miss any event.

[float]
[[log-rotate-example-filebeat]]
===== filebeat.yml

[source,yaml]
-----------------------------------------------------
filebeat.inputs:
- type: log
  enabled: false
  paths:
  - /var/log/my-server/my-server.log*
-----------------------------------------------------

[float]
[[log-rotation-windows]]
=== Additional notes on logrotation on Windows

Log rotation schemes deleting old files and renaming newer files to the old files might get blocked if old
files are still processed by {beatname_uc}. This is due to Windows not deleting files and file meta-data,
until the last process has closed the file. Unlike most *nix filesystems,
one can not reuse a file name, until all processes accessing the file have closed the deleted file.

For Windows users a better strategy is to use dates in the rotated file names.
Thus, a file is never renamed to an older file, and the log writer cannot fail to open files
(same for log rotator, if it's an external process).

This highly reduces the chance of log writing, rotation, and collecting interfering with each other.

Check out Frequently Asked Question about logrotation on Windows:

* <<windows-file-rotation>>
