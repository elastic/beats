// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package net

import (
	"sync"

	v2 "github.com/elastic/beats/v7/filebeat/input/v2"
	"github.com/elastic/elastic-agent-libs/logp"
	"github.com/elastic/elastic-agent-libs/monitoring"
)

// Ensure, that InputMock does implement Input.
// If this is not the case, regenerate this file with moq.
var _ Input = &inputMock{}

// inputMock is a mock implementation of Input.
//
//	func TestSomethingThatUsesInput(t *testing.T) {
//
//		// make and configure a mocked Input
//		mockedInput := &inputMock{
//			InitMetricsFunc: func(id string, reg *monitoring.Registry, logger *logp.Logger) Metrics {
//				panic("mock out the InitMetrics method")
//			},
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//			RunFunc: func(context v2.Context, dataMetadataCh chan<- DataMetadata, metrics Metrics) error {
//				panic("mock out the Run method")
//			},
//			TestFunc: func(testContext v2.TestContext) error {
//				panic("mock out the Test method")
//			},
//		}
//
//		// use mockedInput in code that requires Input
//		// and then make assertions.
//
//	}
type inputMock struct {
	// InitMetricsFunc mocks the InitMetrics method.
	InitMetricsFunc func(id string, reg *monitoring.Registry, logger *logp.Logger) Metrics

	// NameFunc mocks the Name method.
	NameFunc func() string

	// RunFunc mocks the Run method.
	RunFunc func(context v2.Context, dataMetadataCh chan<- DataMetadata, metrics Metrics) error

	// TestFunc mocks the Test method.
	TestFunc func(testContext v2.TestContext) error

	// calls tracks calls to the methods.
	calls struct {
		// InitMetrics holds details about calls to the InitMetrics method.
		InitMetrics []struct {
			// ID is the id argument value.
			ID string
			// Reg is the reg argument value.
			Reg *monitoring.Registry
			// Logger is the logger argument value.
			Logger *logp.Logger
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Context is the context argument value.
			Context v2.Context
			// DataMetadataCh is the dataMetadataCh argument value.
			DataMetadataCh chan<- DataMetadata
			// Metrics is the metrics argument value.
			Metrics Metrics
		}
		// Test holds details about calls to the Test method.
		Test []struct {
			// TestContext is the testContext argument value.
			TestContext v2.TestContext
		}
	}
	lockInitMetrics sync.RWMutex
	lockName        sync.RWMutex
	lockRun         sync.RWMutex
	lockTest        sync.RWMutex
}

// InitMetrics calls InitMetricsFunc.
func (mock *inputMock) InitMetrics(id string, reg *monitoring.Registry, logger *logp.Logger) Metrics {
	if mock.InitMetricsFunc == nil {
		panic("InputMock.InitMetricsFunc: method is nil but Input.InitMetrics was just called")
	}
	callInfo := struct {
		ID     string
		Reg    *monitoring.Registry
		Logger *logp.Logger
	}{
		ID:     id,
		Reg:    reg,
		Logger: logger,
	}
	mock.lockInitMetrics.Lock()
	mock.calls.InitMetrics = append(mock.calls.InitMetrics, callInfo)
	mock.lockInitMetrics.Unlock()
	return mock.InitMetricsFunc(id, reg, logger)
}

// InitMetricsCalls gets all the calls that were made to InitMetrics.
// Check the length with:
//
//	len(mockedInput.InitMetricsCalls())
func (mock *inputMock) InitMetricsCalls() []struct {
	ID     string
	Reg    *monitoring.Registry
	Logger *logp.Logger
} {
	var calls []struct {
		ID     string
		Reg    *monitoring.Registry
		Logger *logp.Logger
	}
	mock.lockInitMetrics.RLock()
	calls = mock.calls.InitMetrics
	mock.lockInitMetrics.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *inputMock) Name() string {
	if mock.NameFunc == nil {
		panic("InputMock.NameFunc: method is nil but Input.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedInput.NameCalls())
func (mock *inputMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *inputMock) Run(context v2.Context, dataMetadataCh chan<- DataMetadata, metrics Metrics) error {
	if mock.RunFunc == nil {
		panic("InputMock.RunFunc: method is nil but Input.Run was just called")
	}
	callInfo := struct {
		Context        v2.Context
		DataMetadataCh chan<- DataMetadata
		Metrics        Metrics
	}{
		Context:        context,
		DataMetadataCh: dataMetadataCh,
		Metrics:        metrics,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(context, dataMetadataCh, metrics)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedInput.RunCalls())
func (mock *inputMock) RunCalls() []struct {
	Context        v2.Context
	DataMetadataCh chan<- DataMetadata
	Metrics        Metrics
} {
	var calls []struct {
		Context        v2.Context
		DataMetadataCh chan<- DataMetadata
		Metrics        Metrics
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Test calls TestFunc.
func (mock *inputMock) Test(testContext v2.TestContext) error {
	if mock.TestFunc == nil {
		panic("InputMock.TestFunc: method is nil but Input.Test was just called")
	}
	callInfo := struct {
		TestContext v2.TestContext
	}{
		TestContext: testContext,
	}
	mock.lockTest.Lock()
	mock.calls.Test = append(mock.calls.Test, callInfo)
	mock.lockTest.Unlock()
	return mock.TestFunc(testContext)
}

// TestCalls gets all the calls that were made to Test.
// Check the length with:
//
//	len(mockedInput.TestCalls())
func (mock *inputMock) TestCalls() []struct {
	TestContext v2.TestContext
} {
	var calls []struct {
		TestContext v2.TestContext
	}
	mock.lockTest.RLock()
	calls = mock.calls.Test
	mock.lockTest.RUnlock()
	return calls
}
