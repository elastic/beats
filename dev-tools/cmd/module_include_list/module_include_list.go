// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/elastic/beats/dev-tools/mage"
	"github.com/elastic/beats/licenses"
)

var usageText = `
Usage: module_include_list [flags] [module-dir]
  module_include_list generates a list.go file containing import statements for
  the module and its dataset packages. The file is usually written to the 
  include/list.go in the Beat's root directory.
Options:
`[1:]

var (
	license string
	pkg     string
	outFile string
)

func init() {
	flag.StringVar(&license, "license", "ASL2", "License header for generated file (ASL2 or Elastic).")
	flag.StringVar(&pkg, "pkg", "include", "Package name.")
	flag.StringVar(&outFile, "out", "include/list.go", "Output file.")
	flag.Usage = usageFlag
}

func main() {
	log.SetFlags(0)
	flag.Parse()

	license, err := licenses.Find(license)
	if err != nil {
		log.Fatalf("Invalid license specifier: %v", err)
	}

	args := flag.Args()
	if len(args) != 1 {
		log.Fatal("module-dir must be passed as an argument.")
	}
	dir := args[0]

	// Find modules and datasets.
	metaDirs, err := mage.FindFiles(
		filepath.Join(dir, "*/_meta"),
		filepath.Join(dir, "*/*/_meta"),
	)
	if err != nil {
		log.Fatalf("Failed finding modules and datasets: %v", err)
	}

	// Get the current directories Go import path.
	repo, err := mage.GetProjectRepoInfo()
	if err != nil {
		log.Fatalf("Failed to determine import path: %v", err)
	}

	// Build import paths.
	var imports []string
	for _, metaDir := range metaDirs {
		importDir := filepath.Dir(metaDir)

		// Skip dirs that have no .go files.
		goFiles, err := filepath.Glob(filepath.Join(importDir, "*.go"))
		if err != nil {
			log.Fatal("Failed checking for .go files in package dir: %v", err)
		}
		if len(goFiles) == 0 {
			continue
		}

		importDir, err = filepath.Rel(mage.CWD(), filepath.Dir(metaDir))
		if err != nil {
			log.Fatal(err)
		}

		imports = append(imports, filepath.ToSlash(
			filepath.Join(repo.ImportPath, importDir)))
	}

	// Populate the template.
	var buf bytes.Buffer
	err = Template.Execute(&buf, Data{
		License: license,
		Package: pkg,
		Imports: imports,
	})
	if err != nil {
		log.Fatal("Failed executing template: %v", err)
	}

	// Create the output directory.
	if err = os.MkdirAll(filepath.Dir(outFile), 0755); err != nil {
		log.Fatal("Failed to create output directory: %v", err)
	}

	// Write the output file.
	if err = ioutil.WriteFile(outFile, buf.Bytes(), 0644); err != nil {
		log.Fatal("Failed writing output file: %v", err)
	}
}

func usageFlag() {
	fmt.Fprintf(os.Stderr, usageText)
	flag.PrintDefaults()
}

var Template = template.Must(template.New("normalizations").Funcs(map[string]interface{}{
	"trim": strings.TrimSpace,
}).Parse(`
{{ .License | trim }}

// Code generated by beats/dev-tools/module_include_list/module_include_list.go - DO NOT EDIT.

package {{ .Package }}

import (
	// Import packages that need to register themselves.
{{- range $import := .Imports }}
	_ "{{ $import }}"
{{- end }}
)
`[1:]))

type Data struct {
	License string
	Package string
	Imports []string
}
