// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.
//
// Resource attributes for Open Telemetry CEL Input Metrics
// Each CEL input has an associated Open Telemetry Resource associated with it. The Resource Attribute Set identifies a
// unique metric set in Elastic. Changing the Resource Attribute Set for input will identify the input's metrics as
// different metric set.
// These Resource Attributes are included for every CEL input instance:
// +--------------------+------------------------------------------------+
// | name               |  description                                   |
// +--------------------+------------------------------------------------+
// |agent.version       | version of agent                               |
// |agent.id            | the id of the agent                            |
// |service.instance.id | id of the cel input instance                   |
// |package.name        | name of the integration package                |
// |package.version     | version of the integration package             |
// |package.data_stream | the datastream name in the integration package |
// +--------------------+------------------------------------------------+

// Resource Attributes that are defined in an OTEL_RESOURCE_ATTRIBUTES environment variable will be added to the CEL
// input instance Resource Attributes set.  An example of an OTEL_RESOURCE_ATTRIBUTES:
//    service.name=elastic-agent,service.version=9.1.2,deployment.environment=production
//
// These attributes are expected in the OTEL_RESOURCE_ATTRIBUTES but not required:
// +------------------------+-------------------------------------------------------+
// | name                   |  description                                          |
// +------------------------+-------------------------------------------------------+
// | service.name,          | service that is running the program, ex. elastic-agent|
// | deployment.environment | deployment environment, ex. production                |
// +------------------------+-------------------------------------------------------+
//
// See [otel.ExportFactory] for environment settings to run console or http/protobuf output.
// See [OTELCELMetrics] for the complete list of exported metrics.

// Open Telemetry Metrics for CEL Input
//
// CEL Metrics are sent as Delta metrics for each Periodic Run (Interval).
// Export occurs as a push to an OTLP endpoint at the end of the Periodic Run. Metrics are reset between Periodic Runs.
// +-------------------------------------------+----------------------------------------------------------------------------------------+------------------+
// | name                                      | description                                                                            | metric type      |
// |-------------------------------------------|----------------------------------------------------------------------------------------|------------------|
// These metrics are generated by the OTEL SDK through wrapping the transport and are scoped in the OTEL metrics as
// ' go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp'.
// A metric is exported for each unique set of attributes:
// - http.request.method
// - http.response.status_code
// - network.protocol.name
// - network.protocol.version
// - server.address
// - server.port
// - url.scheme
//
// +-------------------------------+----------------------------------------------+------------------+
// | name                          | description                                  | metric type      |
// |-------------------------------|----------------------------------------------|------------------|
// | http.client.request.duration  | The duration in seconds for an http request  | Float64Histogram |
// | http.client.request.body.size | The size of the request in bytes             | Int64Histogram   |
// +------------------------------+-----------------------------------------------+------------------+
//
// See cel_metric_collection.png for a diagram of when each OTEL CEL metric is collected.
//
// inputMetrics
//
// inputMetrics are part of the agent monitoring framework. They are cumulative metrics for each input for the entire
// run of a CEL input. They are packaged together with other agent data for monitoring.
// Durations are collected as histograms and are in nanoseconds.
// Cumulative HTTP metrics are collected through a wrapper on the HTTP transport.
// See https://www.elastic.co/guide/en/beats/filebeat/current/http-endpoint.html
// and https://www.elastic.co/docs/reference/fleet/monitor-elastic-agent for details
// on agent monitoring.

package cel

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/rcrowley/go-metrics"

	"github.com/elastic/beats/v7/x-pack/filebeat/otel"
	"github.com/elastic/elastic-agent-libs/logp"
	"github.com/elastic/elastic-agent-libs/monitoring"
	"github.com/elastic/elastic-agent-libs/monitoring/adapter"

	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/noop"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/metric/metricdata"
	"go.opentelemetry.io/otel/sdk/resource"
)

type inputMetrics struct {
	resource            *monitoring.String // URL-ish of input resource
	executions          *monitoring.Uint   // times the CEL program has been executed
	batchesReceived     *monitoring.Uint   // number of event arrays received
	eventsReceived      *monitoring.Uint   // number of events received
	batchesPublished    *monitoring.Uint   // number of event arrays published
	eventsPublished     *monitoring.Uint   // number of events published
	celProcessingTime   metrics.Sample     // histogram of the elapsed successful cel program processing times in nanoseconds
	batchProcessingTime metrics.Sample     // histogram of the elapsed successful batch processing times in nanoseconds (time of receipt to time of ACK for non-empty batches).
}

func newInputMetrics(reg *monitoring.Registry, logger *logp.Logger) (*inputMetrics, *monitoring.Registry) {
	out := &inputMetrics{
		resource:            monitoring.NewString(reg, "resource"),
		executions:          monitoring.NewUint(reg, "cel_executions"),
		batchesReceived:     monitoring.NewUint(reg, "batches_received_total"),
		eventsReceived:      monitoring.NewUint(reg, "events_received_total"),
		batchesPublished:    monitoring.NewUint(reg, "batches_published_total"),
		eventsPublished:     monitoring.NewUint(reg, "events_published_total"),
		celProcessingTime:   metrics.NewUniformSample(1024),
		batchProcessingTime: metrics.NewUniformSample(1024),
	}
	_ = adapter.NewGoMetrics(reg, "cel_processing_time", logger, adapter.Accept).
		Register("histogram", metrics.NewHistogram(out.celProcessingTime))
	_ = adapter.NewGoMetrics(reg, "batch_processing_time", logger, adapter.Accept).
		Register("histogram", metrics.NewHistogram(out.batchProcessingTime))

	return out, reg
}

type OTELCELMetrics struct {
	log                                  *logp.Logger
	shutdownFuncs                        []func(context.Context) error
	manualExportFunc                     func(context.Context) error
	exportLock                           sync.Mutex
	export                               bool
	startRunTime                         time.Time
	periodicRunCount                     metric.Int64Counter
	periodicBatchProcessedCount          metric.Int64Counter
	periodicBatchPublishedCount          metric.Int64Counter
	periodicEventProcessedCount          metric.Int64Counter
	periodicEventPublishedCount          metric.Int64Counter
	periodicRunDuration                  metric.Float64Counter
	periodicCelDuration                  metric.Float64Counter
	periodicEventPublishDuration         metric.Float64Counter
	periodicProgramRunStartedCount       metric.Int64Counter
	periodicProgramRunSuccessCount       metric.Int64Counter
	programBatchProcessedHistogram       metric.Int64Histogram
	programBatchPublishedHistogram       metric.Int64Histogram
	programEventProcessedHistogram       metric.Int64Histogram
	programEventPublishedHistogram       metric.Int64Histogram
	programRunDurationHistogram          metric.Float64Histogram
	programCelDurationHistogram          metric.Float64Histogram
	programEventPublishDurationHistogram metric.Float64Histogram
}

// StartPeriodic starts the periodic metrics collection.
// exportLock blocks starting a new periodic if the
// export is still processing. This should not happen
// in the real world use due to the use of intervals for
// running periodic runs. However, test environments with
// small intervals could potentially cause this to happen.
func (o *OTELCELMetrics) StartPeriodic(ctx context.Context) {
	o.exportLock.Lock() // Acquire the lock
	defer o.exportLock.Unlock()
	o.export = true
	o.periodicRunCount.Add(ctx, 1)
	o.startRunTime = time.Now()
}

// EndPeriodic ends the periodic metrics collection and manually exports metrics if a manual export function is set.
func (o *OTELCELMetrics) EndPeriodic(ctx context.Context) {
	if o.export {
		o.periodicRunDuration.Add(ctx, time.Since(o.startRunTime).Seconds())
	}
	if o.manualExportFunc == nil || !o.export {
		return
	}
	o.exportLock.Lock() // Acquire the lock
	defer o.exportLock.Unlock()
	o.log.Debug("OTELCELMetrics EndPeriodic called")
	o.export = false
	o.log.Debug("OTELCELMetrics manual export export")
	err := o.manualExportFunc(ctx)
	if err != nil {
		o.log.Errorf("error exporting metrics: %v", err)
	}
	o.log.Debug("OTELCELMetrics manual export ended")
}

func (o *OTELCELMetrics) AddProgramRunDuration(ctx context.Context, duration time.Duration) {
	o.programRunDurationHistogram.Record(ctx, duration.Seconds())
}

func (o *OTELCELMetrics) AddPublishDuration(ctx context.Context, duration time.Duration) {
	o.periodicEventPublishDuration.Add(ctx, duration.Seconds())
	o.programEventPublishDurationHistogram.Record(ctx, duration.Seconds())
}

func (o *OTELCELMetrics) AddCELDuration(ctx context.Context, duration time.Duration) {
	o.periodicCelDuration.Add(ctx, duration.Seconds())
	o.programCelDurationHistogram.Record(ctx, duration.Seconds())
}

func (o *OTELCELMetrics) AddReceivedBatch(ctx context.Context, count int64) {
	o.periodicBatchProcessedCount.Add(ctx, count)
	o.programBatchProcessedHistogram.Record(ctx, count)
}

func (o *OTELCELMetrics) AddPublishedBatch(ctx context.Context, count int64) {
	o.periodicBatchPublishedCount.Add(ctx, count)
	o.programBatchPublishedHistogram.Record(ctx, count)
}

func (o *OTELCELMetrics) AddReceivedEvents(ctx context.Context, count int64) {
	o.periodicEventProcessedCount.Add(ctx, count)
	o.programEventProcessedHistogram.Record(ctx, count)
}

func (o *OTELCELMetrics) AddPublishedEvents(ctx context.Context, count int64) {
	o.periodicEventPublishedCount.Add(ctx, count)
	o.programEventPublishedHistogram.Record(ctx, count)
}

func (o *OTELCELMetrics) AddProgramExecutionStarted(ctx context.Context, count int64) {
	o.periodicProgramRunStartedCount.Add(ctx, count)
}

func (o *OTELCELMetrics) AddProgramExecutionSuccess(ctx context.Context, count int64) {
	o.periodicProgramRunSuccessCount.Add(ctx, count)
}

// Shutdown(ctx context.Context) error
// Flushes the meters to the exporters, then shutsdown the exporter
func (o *OTELCELMetrics) Shutdown(ctx context.Context) {
	o.EndPeriodic(ctx)
	var err error
	for _, fn := range o.shutdownFuncs {
		err = errors.Join(err, fn(ctx))
	}
	if err != nil {
		o.log.Errorf("error shutting down metrics: %v", err)
	}
}

func NewOTELCELMetrics(log *logp.Logger,
	resource resource.Resource,
	tripper http.RoundTripper,
	metricExporter sdkmetric.Exporter,
) (*OTELCELMetrics, *otelhttp.Transport, error) {
	var manualExportFunc func(context.Context) error
	var meterProvider metric.MeterProvider
	var shutdownFuncs []func(context.Context) error
	if metricExporter == nil {
		meterProvider = noop.NewMeterProvider()
	} else {
		reader := sdkmetric.NewManualReader(sdkmetric.WithTemporalitySelector(otel.DeltaSelector))

		exponentialView := sdkmetric.NewView(
			sdkmetric.Instrument{
				// captures every histogram that will produced by this provider
				Name: "*",
				Kind: sdkmetric.InstrumentKindHistogram,
			},
			sdkmetric.Stream{
				Aggregation: sdkmetric.AggregationBase2ExponentialHistogram{
					MaxSize:  160, // Optional: configure max buckets
					MaxScale: 20,  // Optional: configure max scale
				},
			},
		)
		sdkMeterProvider := sdkmetric.NewMeterProvider(
			sdkmetric.WithReader(reader),
			sdkmetric.WithResource(&resource),
			sdkmetric.WithView(exponentialView))
		shutdownFuncs = append(shutdownFuncs, sdkMeterProvider.Shutdown)
		meterProvider = sdkMeterProvider

		manualExportFunc = func(ctx context.Context) error {
			collectedMetrics := &metricdata.ResourceMetrics{}
			err := reader.Collect(ctx, collectedMetrics)
			if err != nil {
				return err
			}
			if log.IsDebug() {
				jsonData, err := json.Marshal(collectedMetrics)
				if err == nil {
					log.Debugf("OTELCELMetrics Collected metrics %s", jsonData)
				} else {
					log.Debugf("OTELCELMetrics could not marshall Collected metrics into json %v", collectedMetrics)
				}
			}
			go func(ctx context.Context, log *logp.Logger, metricExporter sdkmetric.Exporter, collectedMetrics *metricdata.ResourceMetrics) {
				err := metricExporter.Export(ctx, collectedMetrics)
				if err != nil {
					log.Error("Failed to export metrics: ", err)
				}
			}(ctx, log, metricExporter, collectedMetrics)
			return nil
		}
	}
	transport := otelhttp.NewTransport(tripper, otelhttp.WithMeterProvider(meterProvider))

	meter := meterProvider.Meter("github.com/elastic/beats/x-pack/filebeat/otel/cel_metrics.go")

	periodicRunCount, err := meter.Int64Counter("input.cel.periodic.run")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.run: %w", err)
	}
	programRunStartedCount, err := meter.Int64Counter("input.cel.periodic.program.run.started")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.run.started: %w", err)
	}
	programRunSuccessCount, err := meter.Int64Counter("input.cel.periodic.program.run.success")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.success: %w", err)
	}
	periodicBatchCount, err := meter.Int64Counter("input.cel.periodic.batch.received")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.batch.received: %w", err)
	}
	periodicPublishedBatchCount, err := meter.Int64Counter("input.cel.periodic.batch.published")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.batch.published: %w", err)
	}
	periodicEventCount, err := meter.Int64Counter("input.cel.periodic.event.received")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.event.received: %w", err)
	}
	periodicPublishedEventCount, err := meter.Int64Counter("input.cel.periodic.event.published")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.event.published: %w", err)
	}
	periodicTotalDuration, err := meter.Float64Counter("input.cel.periodic.run.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.run.duration: %w", err)
	}
	periodicCELDuration, err := meter.Float64Counter("input.cel.periodic.cel.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.cel.duration: %w", err)
	}
	periodicPublishDuration, err := meter.Float64Counter("input.cel.periodic.event.publish.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.periodic.event.publish.duration: %w", err)
	}

	programBatchProcessed, err := meter.Int64Histogram("input.cel.program.batch.received")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.batch.received: %w", err)
	}
	programBatchPublished, err := meter.Int64Histogram("input.cel.program.batch.published")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.batch.published: %w", err)
	}
	programEventGenerated, err := meter.Int64Histogram("input.cel.program.event.received")
	if err != nil {
		return nil, nil, fmt.Errorf("failed"+
			" to create input.cel.program.event.received: %w", err)
	}
	programEventPublished, err := meter.Int64Histogram("input.cel.program.event.published")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.event.published: %w", err)
	}

	programRunDuration, err := meter.Float64Histogram("input.cel.program.run.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.run.duration: %w", err)
	}
	programCELDuration, err := meter.Float64Histogram("input.cel.program.cel.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.cel.duration: %w", err)
	}
	programPublishDuration, err := meter.Float64Histogram("input.cel.program.publish.duration")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create input.cel.program.publish.duration: %w", err)
	}

	return &OTELCELMetrics{
		log:                                  log,
		shutdownFuncs:                        shutdownFuncs,
		manualExportFunc:                     manualExportFunc,
		periodicRunCount:                     periodicRunCount,
		periodicBatchProcessedCount:          periodicBatchCount,
		periodicBatchPublishedCount:          periodicPublishedBatchCount,
		periodicEventProcessedCount:          periodicEventCount,
		periodicEventPublishedCount:          periodicPublishedEventCount,
		periodicRunDuration:                  periodicTotalDuration,
		periodicCelDuration:                  periodicCELDuration,
		periodicEventPublishDuration:         periodicPublishDuration,
		periodicProgramRunStartedCount:       programRunStartedCount,
		periodicProgramRunSuccessCount:       programRunSuccessCount,
		programBatchProcessedHistogram:       programBatchProcessed,
		programBatchPublishedHistogram:       programBatchPublished,
		programEventProcessedHistogram:       programEventGenerated,
		programEventPublishedHistogram:       programEventPublished,
		programRunDurationHistogram:          programRunDuration,
		programCelDurationHistogram:          programCELDuration,
		programEventPublishDurationHistogram: programPublishDuration,
	}, transport, nil
}

type MetricsRecorder struct {
	inputMetrics *inputMetrics
	otelMetrics  *OTELCELMetrics
}

func NewMetricsRecorder(inputMetrics *inputMetrics, otelMetrics *OTELCELMetrics) (*MetricsRecorder, error) {
	if inputMetrics == nil || otelMetrics == nil {
		return nil, errors.New("input metrics and otel metrics cannot be nil")
	}
	return &MetricsRecorder{
		inputMetrics,
		otelMetrics,
	}, nil
}

func (o *MetricsRecorder) StartPeriodic(ctx context.Context) {
	o.otelMetrics.StartPeriodic(ctx)
}

// EndPeriodic ends the periodic metrics collection and manually exports metrics if a manual export function is set.
func (o *MetricsRecorder) EndPeriodic(ctx context.Context) {
	o.otelMetrics.EndPeriodic(ctx)
}

func (o *MetricsRecorder) AddCELDuration(ctx context.Context, duration time.Duration) {
	o.otelMetrics.AddCELDuration(ctx, duration)
	o.inputMetrics.celProcessingTime.Update(duration.Nanoseconds())
}

func (o *MetricsRecorder) AddProgramRunDuration(ctx context.Context, duration time.Duration) {
	o.otelMetrics.AddProgramRunDuration(ctx, duration)
}

func (o *MetricsRecorder) AddPublishDuration(ctx context.Context, duration time.Duration) {
	o.otelMetrics.AddPublishDuration(ctx, duration)
	o.inputMetrics.batchProcessingTime.Update(duration.Nanoseconds())
}

func (o *MetricsRecorder) AddReceivedBatch(ctx context.Context, count uint) {
	o.inputMetrics.batchesReceived.Add(uint64(count))
	o.otelMetrics.AddReceivedBatch(ctx, int64(count)) //nolint:gosec // disable G115
}

func (o *MetricsRecorder) AddPublishedBatch(ctx context.Context, count uint) {
	o.inputMetrics.batchesPublished.Add(uint64(count))
	o.otelMetrics.AddPublishedBatch(ctx, int64(count)) //nolint:gosec // disable G115
}

func (o *MetricsRecorder) AddReceivedEvents(ctx context.Context, count uint) {
	o.inputMetrics.eventsReceived.Add(uint64(count))
	o.otelMetrics.AddReceivedEvents(ctx, int64(count)) //nolint:gosec // disable G115
}

func (o *MetricsRecorder) AddPublishedEvents(ctx context.Context, count uint) {
	o.inputMetrics.eventsPublished.Add(uint64(count))
	o.otelMetrics.AddPublishedEvents(ctx, int64(count)) //nolint:gosec // disable G115
}

func (o *MetricsRecorder) AddProgramExecution(ctx context.Context) {
	o.inputMetrics.executions.Add(1)
	o.otelMetrics.AddProgramExecutionStarted(ctx, 1)
}

func (o *MetricsRecorder) AddProgramSuccessExecution(ctx context.Context) {
	o.otelMetrics.AddProgramExecutionSuccess(ctx, 1)
}

func (o *MetricsRecorder) SetResourceURL(url string) {
	o.inputMetrics.resource.Set(url)
}
