// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package httpjson

import (
	"context"
	"os"
	"sync"
	"testing"

	"golang.org/x/sync/errgroup"

	"github.com/elastic/beats/filebeat/channel"
	"github.com/elastic/beats/filebeat/input"
	"github.com/elastic/beats/libbeat/beat"
	"github.com/elastic/beats/libbeat/common"
	"github.com/elastic/beats/libbeat/logp"
	"github.com/elastic/beats/libbeat/tests/resources"
)

var (
	once sync.Once
	host = "httpbin.org"
)

func testSetup(t *testing.T) {
	t.Helper()

	once.Do(func() {
		logp.TestingSetup()
	})
}

func isInDockerIntegTestEnv() bool {
	return os.Getenv("BEATS_DOCKER_INTEGRATION_TEST_ENV") != ""
}

func runTest(t *testing.T, cfg *common.Config, run func(input *httpjsonInput, out *stubOutleter, t *testing.T)) {
	if !isInDockerIntegTestEnv() {
		// Don't test goroutines when using our compose.EnsureUp.
		defer resources.NewGoroutinesChecker().Check(t)
	}

	// Setup httpbin environment
	testSetup(t)

	// Simulate input.Context from Filebeat input runner.
	inputCtx := newInputContext()
	defer close(inputCtx.Done)

	// Stub outlet for receiving events generated by the input.
	eventOutlet := newStubOutlet()
	defer eventOutlet.Close()

	connector := channel.ConnectorFunc(func(_ *common.Config, _ beat.ClientConfig) (channel.Outleter, error) {
		return eventOutlet, nil
	})

	in, err := NewInput(cfg, connector, inputCtx)
	if err != nil {
		t.Fatal(err)
	}
	input := in.(*httpjsonInput)
	defer input.Stop()

	run(input, eventOutlet, t)
}

func newInputContext() input.Context {
	return input.Context{
		Done: make(chan struct{}),
	}
}

type stubOutleter struct {
	sync.Mutex
	cond   *sync.Cond
	done   bool
	Events []beat.Event
}

func newStubOutlet() *stubOutleter {
	o := &stubOutleter{}
	o.cond = sync.NewCond(o)
	return o
}

func (o *stubOutleter) waitForEvents(numEvents int) ([]beat.Event, bool) {
	o.Lock()
	defer o.Unlock()

	for len(o.Events) < numEvents && !o.done {
		o.cond.Wait()
	}

	size := numEvents
	if size >= len(o.Events) {
		size = len(o.Events)
	}

	out := make([]beat.Event, size)
	copy(out, o.Events)
	return out, len(out) == numEvents
}

func (o *stubOutleter) Close() error {
	o.Lock()
	defer o.Unlock()
	o.done = true
	return nil
}

func (o *stubOutleter) Done() <-chan struct{} { return nil }

func (o *stubOutleter) OnEvent(event beat.Event) bool {
	o.Lock()
	defer o.Unlock()
	o.Events = append(o.Events, event)
	o.cond.Broadcast()
	return !o.done
}

// --- Test Cases

func TestGET(t *testing.T) {
	cfg := common.MustNewConfigFrom(map[string]interface{}{
		"http_method": "GET",
		"interval":    0,
		"url":         "http://" + host + "/json",
	})

	runTest(t, cfg, func(input *httpjsonInput, out *stubOutleter, t *testing.T) {
		group, _ := errgroup.WithContext(context.Background())
		group.Go(input.run)

		events, ok := out.waitForEvents(1)
		if !ok {
			t.Fatalf("Expected 1 events, but got %d.", len(events))
		}
		input.Stop()

		if err := group.Wait(); err != nil {
			t.Fatal(err)
		}
	})
}

func TestPOST(t *testing.T) {
	cfg := common.MustNewConfigFrom(map[string]interface{}{
		"http_method":       "POST",
		"http_request_body": map[string]interface{}{"test": "abc", "testNested": map[string]interface{}{"testNested1": 123}},
		"interval":          0,
		"url":               "https://" + host + "/post",
	})

	runTest(t, cfg, func(input *httpjsonInput, out *stubOutleter, t *testing.T) {
		group, _ := errgroup.WithContext(context.Background())
		group.Go(input.run)

		events, ok := out.waitForEvents(1)
		if !ok {
			t.Fatalf("Expected 1 events, but got %d.", len(events))
		}
		input.Stop()

		if err := group.Wait(); err != nil {
			t.Fatal(err)
		}
	})
}

func TestRunStop(t *testing.T) {
	cfg := common.MustNewConfigFrom(map[string]interface{}{
		"http_method": "GET",
		"interval":    0,
		"url":         "http://" + host + "/json",
	})

	runTest(t, cfg, func(input *httpjsonInput, out *stubOutleter, t *testing.T) {
		input.Run()
		input.Stop()
		input.Run()
		input.Stop()
	})
}
