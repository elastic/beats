// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

//go:build !aix
// +build !aix

package azureeventhub

import (
	"fmt"
	"testing"
	"time"

	eventhub "github.com/Azure/azure-event-hubs-go/v3"
	"github.com/stretchr/testify/assert"

	"github.com/elastic/elastic-agent-libs/logp"
	"github.com/elastic/elastic-agent-libs/monitoring"
)

func TestInputMetricsEventsReceived(t *testing.T) {

	var sn int64 = 12
	now := time.Now()
	var off int64 = 1234
	var pID int16 = 1

	properties := eventhub.SystemProperties{
		SequenceNumber: &sn,
		EnqueuedTime:   &now,
		Offset:         &off,
		PartitionID:    &pID,
		PartitionKey:   nil,
	}

	log := logp.NewLogger(fmt.Sprintf("%s test for input", inputName))

	//

	cases := []struct {
		event                       string
		expectedRecords             []string
		sanitizationOption          []string
		eventsReceived              uint64
		eventsSanitized             uint64
		eventsDeserializationFailed uint64
		eventsProcessed             uint64
		eventsProcessingTime        uint64
		recordsReceived             uint64
		recordsSerializationFailed  uint64
		recordsDispatchFailed       uint64
		recordsProcessed            uint64
	}{
		{
			event:                       "{\"records\": [{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}]}",
			expectedRecords:             []string{"{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}"},
			eventsReceived:              1,
			eventsSanitized:             0,
			eventsDeserializationFailed: 0,
			eventsProcessed:             1,
			recordsReceived:             1,
			recordsSerializationFailed:  0,
			recordsDispatchFailed:       0,
			recordsProcessed:            1,
		},
		{
			event: "{\"records\": [{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}, {\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}]}",
			expectedRecords: []string{
				"{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}",
				"{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}",
			},
			eventsReceived:              1,
			eventsSanitized:             0,
			eventsDeserializationFailed: 0,
			eventsProcessed:             1,
			recordsReceived:             2,
			recordsSerializationFailed:  0,
			recordsDispatchFailed:       0,
			recordsProcessed:            2,
		},
		{
			event: "{\"records\": [{'test':'this is some message','time':'2019-12-17T13:43:44.4946995Z'}]}", // Thank you, Azure Functions logs.
			expectedRecords: []string{
				"{\"test\":\"this is some message\",\"time\":\"2019-12-17T13:43:44.4946995Z\"}",
			},
			sanitizationOption:          []string{"SINGLE_QUOTES"},
			eventsReceived:              1,
			eventsSanitized:             1,
			eventsDeserializationFailed: 0,
			eventsProcessed:             1,
			recordsReceived:             1,
			recordsSerializationFailed:  0,
			recordsDispatchFailed:       0,
			recordsProcessed:            1,
		},
		{
			event: "{\"records\": [{'test':'this is some message','time':'2019-12-17T13:43:44.4946995Z'}]}",
			expectedRecords: []string{
				"{\"records\": [{'test':'this is some message','time':'2019-12-17T13:43:44.4946995Z'}]}",
			},
			sanitizationOption:          []string{}, // no sanitization options
			eventsReceived:              1,
			eventsSanitized:             0, // Because we have no sanitization options.
			eventsDeserializationFailed: 1,
			eventsProcessed:             1,
			recordsReceived:             0,
			recordsSerializationFailed:  0,
			recordsDispatchFailed:       0,
			recordsProcessed:            1,
		},
	}

	for _, tc := range cases {

		inputConfig := azureInputConfig{
			SAKey:            "",
			SAName:           "",
			SAContainer:      ephContainerName,
			ConnectionString: "",
			ConsumerGroup:    "",
			SanitizeOptions:  tc.sanitizationOption,
		}

		reg := monitoring.NewRegistry()
		metrics := newInputMetrics("test", reg)

		// Stub outlet for receiving events generated by the input.
		o := &stubOutleter{}
		out, err := newStubOutlet(o)
		if err != nil {
			t.Fatal(err)
		}

		input := azureInput{
			config:  inputConfig,
			metrics: metrics,
			outlet:  out,
			log:     log,
		}

		ev := eventhub.Event{
			Data:             []byte(tc.event),
			SystemProperties: &properties,
		}

		ok := input.processEvents(&ev, "0")
		if !ok {
			t.Fatal("OnEvent function returned false")
		}

		if ok := assert.Equal(t, len(tc.expectedRecords), len(o.Events)); ok {
			for i, e := range o.Events {
				msg, err := e.Fields.GetValue("message")
				if err != nil {
					t.Fatal(err)
				}
				assert.Equal(t, msg, tc.expectedRecords[i])
			}
		}

		assert.True(t, metrics.eventsProcessingTime.Size() > 0) // TODO: is this the right way of checking if we collected some processing time?

		assert.Equal(t, tc.eventsReceived, metrics.eventsReceived.Get())
		assert.Equal(t, tc.eventsSanitized, metrics.eventsSanitized.Get())
		assert.Equal(t, tc.eventsDeserializationFailed, metrics.eventsDeserializationFailed.Get())
		assert.Equal(t, tc.eventsProcessed, metrics.eventsProcessed.Get())

		assert.Equal(t, tc.recordsReceived, metrics.recordsReceived.Get())
		assert.Equal(t, tc.recordsSerializationFailed, metrics.recordsSerializationFailed.Get())
		assert.Equal(t, tc.recordsDispatchFailed, metrics.recordsDispatchFailed.Get())
		assert.Equal(t, tc.recordsProcessed, metrics.recordsProcessed.Get())

		metrics.Close()
	}
}
