// Code generated by ragel DO NOT EDIT.

package cef

import (
    "fmt"
    "strconv"

    "go.uber.org/multierr"
)

%%{
    machine cef;
    write data;
    variable p p;
    variable pe pe;
}%%

// unpack unpacks a CEF message.
func (e *Event) unpack(data string) error {
    cs, p, pe, eof := 0, 0, len(data), len(data)
    mark, mark_slash := 0, 0

    // state related to CEF values.
    var state cefState

    // flag for completion of CEF header.
    complete := false

    // recoveredErrs are problems with the message that the parser was able to
    // recover from (though the parsing might not be "correct").
    var recoveredErrs []error

    e.init(data)

    %%{
        include cef "cef_actions.rl";
        include cef "cef.rl";

        header = version pipe
                 device_vendor >mark %device_vendor pipe
                 device_product >mark %device_product pipe
                 device_version >mark %device_version pipe
                 device_event_class_id >mark %device_event_class_id pipe
                 name >mark %name pipe
                 severity >mark %severity pipe;

        # CEF message.
        cef = header %complete_header extensions?;

        main := cef;
        write init;
        write exec;
    }%%

    // Check if state machine completed.
    if cs < cef_first_final {
        // Reached an early end.
        if p == pe {
            if complete {
                return multierr.Append(multierr.Combine(recoveredErrs...), errUnexpectedEndOfEvent)
            }
            return multierr.Append(multierr.Combine(recoveredErrs...), multierr.Combine(errUnexpectedEndOfEvent, errIncompleteHeader))
        }

        // Encountered invalid input.
        return multierr.Append(multierr.Combine(recoveredErrs...), fmt.Errorf("error in CEF event at pos %d", p+1))
    }

    return multierr.Combine(recoveredErrs...)
}
