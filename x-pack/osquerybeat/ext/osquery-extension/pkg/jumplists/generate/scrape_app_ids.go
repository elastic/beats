// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// Code generated by beats/x-pack/osquerybeat/ext/osquery-extension/pkg/jumplists/parsers/application_id_generate.go - DO NOT EDIT.

//go:build windows

package main

import (
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/logger"
)

const appIdSourceUrl = "https://raw.githubusercontent.com/EricZimmerman/JumpList/refs/heads/master/JumpList/Resources/AppIDs.txt"

// scrapeJumpListAppIDs replicates the second Python scraping function.
func scrapeJumpListAppIDs(log *logger.Logger) (map[string]string, error) {
	appIDs := make(map[string]string)
	valueRegex := regexp.MustCompile(`.*"(.*)"`)
	bodyString, err := downloadRawPage(appIdSourceUrl, log)
	if err != nil {
		return nil, err
	}

	// for line in ... .splitlines()
	lines := strings.Split(bodyString, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue // Skip empty lines
		}

		// app_id_raw, app_name_raw = line.strip().split('|')
		parts := strings.Split(line, "|")
		if len(parts) != 2 {
			log.Infof("invalid line in response: %s", line)
			continue
		}
		appIDRaw := parts[0]
		appNameRaw := parts[1]

		appIDMatches := valueRegex.FindStringSubmatch(appIDRaw)
		appNameMatches := valueRegex.FindStringSubmatch(appNameRaw)

		if len(appIDMatches) < 2 || len(appNameMatches) < 2 {
			log.Infof("failed to parse quoted values from response: %s", line)
			continue
		}

		appID := appIDMatches[1]
		appName := appNameMatches[1]

		if isHexString.MatchString(appID) {
			appIDs[strings.ToLower(appID)] = appName
		} else {
			log.Infof("Invalid app id in response: %s", line)
		}
	}

	return appIDs, nil
}

func writeAppIdGeneratedFile(outputFile string, log *logger.Logger) error {
	log.Infof("outputting %s", outputFile)
	
	appIDs, err := scrapeJumpListAppIDs(log)
	if err != nil {
		return err
	}

	// Build the Go map literal string
	// Using strings.Builder is more efficient than repeated string concatenation
	var sb strings.Builder
	writeCopyrightHeader(&sb)
	sb.WriteString("// jumpListAppIds is a lookup table for known windows AppIDs.\n")
	sb.WriteString(fmt.Sprintf("// Source: %s\n", appIdSourceUrl))
	sb.WriteString("var jumpListAppIds = map[string]string{\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(appIDs))
	for k := range appIDs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, appID := range keys {
		appName := appIDs[appID]
		sb.WriteString(fmt.Sprintf("\t%-20s: %q,\n", fmt.Sprintf("\"%s\"", appID), appName))
	}
	sb.WriteString("}\n")

	err = os.WriteFile(outputFile, []byte(sb.String()), 0644)
	if err != nil {
		return err
	}

	log.Infof("Generated %s successfully", outputFile)
	return nil
}
