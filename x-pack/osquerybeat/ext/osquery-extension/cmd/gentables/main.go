// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

//go:generate go run . -verbose

package main

import (
	"bytes"
	"embed"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/pingcap/parser"
	"github.com/pingcap/parser/ast"
	"github.com/pingcap/parser/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	// test_driver is required for the parser to work. It registers the AST node constructors
	// via init(). Without it, parser.New() will panic with "no parser driver".
	// See: https://github.com/pingcap/parser/issues/43
	_ "github.com/pingcap/parser/test_driver"

	"gopkg.in/yaml.v3"
)

// spec represents a unified specification for both tables and views
type spec struct {
	Type                  string              `yaml:"type"` // "table" or "view"
	Name                  string              `yaml:"name"`
	Description           string              `yaml:"description"`
	Platforms             []string            `yaml:"platforms"`
	Group                 string              `yaml:"group,omitempty"`
	Columns               []columnSpec        `yaml:"columns"`
	EmbeddedTypes         []sharedTypeSpec    `yaml:"-"`                      // Shared types resolved from shared_types specs
	SharedTypes           []string            `yaml:"shared_types,omitempty"` // References to shared type names from shared types spec
	Documentation         documentationConfig `yaml:"documentation"`
	ImplementationPackage string              `yaml:"implementation_package,omitempty"`

	// View-specific fields
	Query          string   `yaml:"query,omitempty"`
	RequiredTables []string `yaml:"required_tables,omitempty"`

	// Internal field to track source file (not from YAML)
	sourceFile string
}

type columnSpec struct {
	Name         string `yaml:"name"`
	Type         string `yaml:"type"`
	Description  string `yaml:"description"`
	Format       string `yaml:"format,omitempty"`        // Optional: "unix", "rfc3339"
	Timezone     string `yaml:"timezone,omitempty"`      // Optional: "UTC", etc.
	GoType       string `yaml:"go_type,omitempty"`       // Optional: explicit Go type override (e.g., "time.Time")
	EmbeddedType string `yaml:"embedded_type,omitempty"` // Optional: reference to an embedded type name
	SharedType   string `yaml:"shared_type,omitempty"`   // Optional: same as embedded_type, used in table YAML
}

// sharedTypeSpec defines a reusable shared struct type across specs
type sharedTypeSpec struct {
	Name        string       `yaml:"name"`                  // Go struct name (e.g., "ApplicationID")
	Description string       `yaml:"description,omitempty"` // Optional description
	Pointer     bool         `yaml:"pointer,omitempty"`     // Whether to embed as pointer (*Type vs Type)
	Columns     []columnSpec `yaml:"columns"`               // Column definitions for the embedded type
}

// sharedTypesFile represents the shared types spec format
type sharedTypesFile struct {
	Type       string           `yaml:"type,omitempty"` // Optional: "shared_types" when defined in a spec file
	Group      string           `yaml:"group"`          // Required group name (scopes types to a table/view group)
	Types      []sharedTypeSpec `yaml:"types"`
	sourceFile string           `yaml:"-"`
}

type sharedTypesConfig struct {
	TypesByGroup       map[string]map[string]sharedTypeSpec
	ImportPathByGroup  map[string]string
	PackageNameByGroup map[string]string
}

type documentationConfig struct {
	Description   string         `yaml:"description"` // Optional for tables, required for views
	Examples      []exampleQuery `yaml:"examples"`
	Notes         []string       `yaml:"notes"`
	RelatedTables []string       `yaml:"related_tables"` // Optional
}

type exampleQuery struct {
	Title string `yaml:"title"`
	Query string `yaml:"query"`
}

const (
	elasticCopyrightHeader = `// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

`
	codeGeneratedNotice = "// Code generated by gentables. DO NOT EDIT.\n"
)

var (
	specDir  = flag.String("spec-dir", "../../specs", "Comma-separated directories containing YAML specifications (tables and views)")
	outDir   = flag.String("out-dir", "../../pkg/tables/generated", "Output directory for generated table Go files")
	viewsOut = flag.String("views-out-dir", "../../pkg/views/generated", "Output directory for generated view Go files")
	docsDir  = flag.String("docs-dir", "../../docs/tables", "Output directory for generated table documentation")
	viewsDoc = flag.String("views-docs-dir", "../../docs/views", "Output directory for generated view documentation")
	verbose  = flag.Bool("verbose", false, "Verbose output")
)

func main() {
	flag.Parse()

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Load all files once and categorize them
	specDirs := splitSpecDirs(*specDir)
	specFiles, sharedTypeFiles, err := loadAllFiles(specDirs)
	if err != nil {
		return fmt.Errorf("failed to load files: %w", err)
	}

	// Parse shared types first (needed for spec resolution)
	sharedTypesConfig, err := loadSharedTypes(sharedTypeFiles)
	if err != nil {
		return fmt.Errorf("failed to load shared types: %w", err)
	}

	// Parse all YAML spec files
	specs, err := loadSpecs(specFiles, sharedTypesConfig)
	if err != nil {
		return fmt.Errorf("failed to load specs: %w", err)
	}

	if *verbose {
		tableCount := 0
		viewCount := 0
		for _, s := range specs {
			switch s.Type {
			case "table":
				tableCount++
			case "view":
				viewCount++
			}
		}
		fmt.Printf("Loaded %d specifications (%d tables, %d views)\n", len(specs), tableCount, viewCount)
	}

	// Create output directories
	if err := os.MkdirAll(*outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	if err := os.MkdirAll(*docsDir, 0755); err != nil {
		return fmt.Errorf("failed to create docs directory: %w", err)
	}
	if err := os.MkdirAll(*viewsOut, 0755); err != nil {
		return fmt.Errorf("failed to create views output directory: %w", err)
	}
	if err := os.MkdirAll(*viewsDoc, 0755); err != nil {
		return fmt.Errorf("failed to create views docs directory: %w", err)
	}

	// Generate shared types packages per group (after specs loaded)
	if sharedTypesConfig != nil {
		if err := generateSharedTypesPackages(sharedTypesConfig, *outDir, specs); err != nil {
			return fmt.Errorf("failed to generate shared types packages: %w", err)
		}
	}

	var tableSpecs, viewSpecs []spec

	// Generate code and documentation for each spec
	for _, s := range specs {
		if *verbose {
			fmt.Printf("Processing %s: %s\n", s.Type, s.Name)
		}

		// Validate the spec based on type
		if err := validateSpec(s); err != nil {
			return fmt.Errorf("%s %s: %w", s.Type, s.Name, err)
		}

		// Route to appropriate generator based on type
		switch s.Type {
		case "table":
			tableSpecs = append(tableSpecs, s)
			// Generate Go code
			if err := generateTableCode(s, *outDir, sharedTypesConfig); err != nil {
				return fmt.Errorf("failed to generate code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *docsDir); err != nil {
				return fmt.Errorf("failed to generate docs for %s: %w", s.Name, err)
			}

		case "view":
			viewSpecs = append(viewSpecs, s)
			// Generate Go code
			if err := generateViewCode(s, *viewsOut, sharedTypesConfig); err != nil {
				return fmt.Errorf("failed to generate view code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *viewsDoc); err != nil {
				return fmt.Errorf("failed to generate view docs for %s: %w", s.Name, err)
			}

		default:
			return fmt.Errorf("spec %s has invalid type: %q (must be 'table' or 'view')", s.Name, s.Type)
		}
	}

	// Note: registry files are now static and not generated
	// They live in pkg/tables/registry.go and pkg/views/registry.go

	// Generate static registry files (including empty registries)
	if err := generateStaticTablesRegistry(tableSpecs, *outDir); err != nil {
		return fmt.Errorf("failed to generate static tables registry: %w", err)
	}

	if err := generateStaticViewsRegistry(viewSpecs, *viewsOut); err != nil {
		return fmt.Errorf("failed to generate static views registry: %w", err)
	}

	if *verbose {
		fmt.Println("Code generation completed successfully")
		fmt.Println("Formatting generated code...")
	}

	// Format all generated Go files
	if err := formatGeneratedFiles(*outDir, *viewsOut); err != nil {
		return fmt.Errorf("failed to format generated files: %w", err)
	}

	if *verbose {
		fmt.Println("Formatting completed successfully")
	}

	return nil
}

// fileContent holds a file's path and its pre-read data
type fileContent struct {
	path string
	data []byte
}

// loadAllFiles reads all spec files once and categorizes them
func loadAllFiles(dirs []string) (specs []fileContent, sharedTypes []fileContent, err error) {
	files, err := collectSpecFiles(dirs)
	if err != nil {
		return nil, nil, err
	}

	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to read %s: %w", file, err)
		}

		// Quick parse to check type field
		var header struct {
			Type string `yaml:"type"`
		}
		if err := yaml.Unmarshal(data, &header); err != nil {
			return nil, nil, fmt.Errorf("failed to parse %s: %w", file, err)
		}

		fc := fileContent{path: file, data: data}
		if header.Type == "shared_types" {
			sharedTypes = append(sharedTypes, fc)
		} else {
			specs = append(specs, fc)
		}
	}

	return specs, sharedTypes, nil
}

func loadSpecs(specFiles []fileContent, sharedTypesConfig *sharedTypesConfig) ([]spec, error) {
	specs := make([]spec, 0, len(specFiles))
	for _, fc := range specFiles {
		var s spec
		if err := yaml.Unmarshal(fc.data, &s); err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", fc.path, err)
		}

		// Store the source file path for reference
		s.sourceFile = fc.path
		applyDefaults(&s)

		// Resolve shared type references
		if err := resolveSharedTypes(&s, sharedTypesConfig); err != nil {
			return nil, fmt.Errorf("failed to resolve shared types for %s: %w", fc.path, err)
		}

		specs = append(specs, s)
	}

	return specs, nil
}

// loadSharedTypes loads shared types from pre-read file contents.
func loadSharedTypes(sharedTypeFiles []fileContent) (*sharedTypesConfig, error) {
	if len(sharedTypeFiles) == 0 {
		return nil, nil
	}

	sharedFiles := make([]sharedTypesFile, 0, len(sharedTypeFiles))
	for _, fc := range sharedTypeFiles {
		var stf sharedTypesFile
		if err := yaml.Unmarshal(fc.data, &stf); err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", fc.path, err)
		}
		stf.sourceFile = fc.path
		sharedFiles = append(sharedFiles, stf)
	}

	merged, err := mergeSharedTypesFiles(sharedFiles)
	if err != nil {
		return nil, err
	}

	if *verbose {
		fmt.Printf("Loaded %d shared types from %d shared types spec(s)\n", countSharedTypes(merged.TypesByGroup), len(sharedFiles))
	}

	return merged, nil
}

func splitSpecDirs(value string) []string {
	parts := strings.Split(value, ",")
	var dirs []string
	for _, part := range parts {
		trimmed := strings.TrimSpace(part)
		if trimmed == "" {
			continue
		}
		dirs = append(dirs, trimmed)
	}
	return dirs
}

func collectSpecFiles(dirs []string) ([]string, error) {
	fileSet := make(map[string]bool)
	var files []string

	for _, dir := range dirs {
		for _, ext := range []string{"*.yaml", "*.yml"} {
			matches, err := filepath.Glob(filepath.Join(dir, ext))
			if err != nil {
				return nil, err
			}
			for _, f := range matches {
				if !fileSet[f] {
					fileSet[f] = true
					files = append(files, f)
				}
			}
		}
	}

	return files, nil
}

func countSharedTypes(byGroup map[string]map[string]sharedTypeSpec) int {
	total := 0
	for _, types := range byGroup {
		total += len(types)
	}
	return total
}

// resolveSharedTypes adds shared type definitions to the spec based on shared_types references.
func resolveSharedTypes(s *spec, cfg *sharedTypesConfig) error {
	if cfg == nil {
		return nil
	}
	if len(s.SharedTypes) > 0 && s.Group == "" {
		return fmt.Errorf("shared_types requires 'group' to be set on %s", s.Name)
	}

	groupTypes := cfg.TypesByGroup[s.Group]

	for _, typeName := range s.SharedTypes {
		if groupTypes != nil {
			if sharedType, ok := groupTypes[typeName]; ok {
				s.EmbeddedTypes = append(s.EmbeddedTypes, sharedType)
				continue
			}
		}
		if s.Group != "" {
			return fmt.Errorf("shared type %q not found in group %q", typeName, s.Group)
		}
		return fmt.Errorf("shared type %q not found", typeName)
	}
	return nil
}

// applyTableDefaults applies sensible defaults to table spec fields
// applyDefaults applies sensible defaults to spec fields
func applyDefaults(s *spec) {
	// Default to all platforms if not specified
	if len(s.Platforms) == 0 {
		s.Platforms = []string{"linux", "darwin", "windows"}
	}

	// Ensure RelatedTables is not nil
	if s.Documentation.RelatedTables == nil {
		s.Documentation.RelatedTables = []string{}
	}
}

type resultField struct {
	IsEmbedded  bool
	Comment     string
	TypeName    string
	Pointer     bool
	Name        string
	Type        string
	Tag         string
	Description string
}

type tableTemplateData struct {
	CopyrightHeader     string
	CodeGeneratedNotice string
	SourceLine          string
	BuildTagLine        string
	PackageName         string
	NeedsTimeImport     bool
	NeedsSharedImport   bool
	SharedImport        string
	Name                string
	Description         string
	ResultFields        []resultField
}

type viewTemplateData struct {
	CopyrightHeader     string
	CodeGeneratedNotice string
	SourceLine          string
	BuildTagLine        string
	PackageName         string
	NeedsTimeImport     bool
	NeedsSharedImport   bool
	SharedImport        string
	Name                string
	HookName            string
	Description         string
	ResultFields        []resultField
	ColumnsComment      []string
	RequiredTables      string
	ViewSQL             string
}

type structField struct {
	Name        string
	Type        string
	Tag         string
	Description string
}

type sharedTypeTemplate struct {
	Name        string
	Description string
	Fields      []structField
}

type sharedTypesTemplateData struct {
	CopyrightHeader     string
	CodeGeneratedNotice string
	PackageName         string
	NeedsTimeImport     bool
	Types               []sharedTypeTemplate
}

type schemaRow struct {
	Name        string
	Type        string
	Description string
}

type docTemplateData struct {
	Name            string
	Description     string
	PlatformLines   []string
	LongDescription string
	SchemaRows      []schemaRow
	IsView          bool
	RequiredTables  []string
	ViewDefinition  string
	CodeFence       string
	CodeQuote       string
	Examples        []exampleQuery
	Notes           []string
	RelatedTables   []string
}

type importEntry struct {
	Alias string
	Path  string
}

type tableRegistryData struct {
	Header       string
	HasTables    bool
	ImplImports  []string
	TableImports []importEntry
	Entries      []registryEntry
}

type viewRegistryData struct {
	Header      string
	HasViews    bool
	ViewImports []importEntry
	Entries     []registryEntry
}

type registryEntry struct {
	Name         string
	Description  string
	PackageAlias string
}

//go:embed templates/*.tmpl
var templatesFS embed.FS

func renderTemplate(name, templatePath string, data any) (string, error) {
	content, err := templatesFS.ReadFile(templatePath)
	if err != nil {
		return "", err
	}
	t, err := template.New(name).Parse(string(content))
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func buildSourceLine(sourceType, sourceFile string) string {
	if sourceFile != "" {
		return fmt.Sprintf("// Source: %s/%s\n\n", sourceType, filepath.Base(sourceFile))
	}
	return fmt.Sprintf("// Source: %s (generated)\n\n", sourceType)
}

func buildBuildTagLine(platforms []string) string {
	if len(platforms) > 0 && !containsAll(platforms, []string{"linux", "darwin", "windows"}) {
		return "//go:build " + strings.Join(platforms, " || ") + "\n\n"
	}
	return ""
}

func needsTimeImportForSpec(s spec) bool {
	for _, col := range s.Columns {
		if osqueryTypeToGoType(col) == "time.Time" {
			return true
		}
	}
	for _, et := range s.EmbeddedTypes {
		for _, col := range et.Columns {
			if osqueryTypeToGoType(col) == "time.Time" {
				return true
			}
		}
	}
	return false
}

func buildResultFields(s spec, typeMap map[string]sharedTypeSpec, needsSharedImport bool, sharedPkgName string) ([]resultField, error) {
	fields := make([]resultField, 0, len(s.Columns))
	for _, col := range s.Columns {
		typeName := embeddedTypeName(col)
		if typeName != "" {
			et, ok := typeMap[typeName]
			if !ok {
				return nil, fmt.Errorf("column %s references unknown embedded type %s", col.Name, typeName)
			}
			typeName := et.Name
			if needsSharedImport && sharedPkgName != "" {
				typeName = sharedPkgName + "." + et.Name
			}
			fields = append(fields, resultField{
				IsEmbedded: true,
				Comment:    et.Description,
				TypeName:   typeName,
				Pointer:    et.Pointer,
			})
			continue
		}

		fields = append(fields, resultField{
			Name:        toTitleCase(col.Name),
			Type:        osqueryTypeToGoType(col),
			Tag:         buildStructTag(col),
			Description: col.Description,
		})
	}
	return fields, nil
}

// sharedTypesInfo holds resolved shared types information for code generation
type sharedTypesInfo struct {
	EmbeddedTypeMap map[string]sharedTypeSpec
	NeedsImport     bool
	ImportPath      string
	PackageName     string
	NeedsTimeImport bool
	ResultFields    []resultField
}

// resolveSharedTypesInfo resolves shared types information needed for code generation
func resolveSharedTypesInfo(s spec, cfg *sharedTypesConfig) (*sharedTypesInfo, error) {
	info := &sharedTypesInfo{
		EmbeddedTypeMap: make(map[string]sharedTypeSpec),
		NeedsTimeImport: needsTimeImportForSpec(s),
	}

	for _, et := range s.EmbeddedTypes {
		info.EmbeddedTypeMap[et.Name] = et
	}

	info.NeedsImport = cfg != nil && len(s.SharedTypes) > 0
	if info.NeedsImport {
		importPath, ok := cfg.ImportPathByGroup[s.Group]
		if !ok || importPath == "" {
			return nil, fmt.Errorf("shared types import path not found for group %q", s.Group)
		}
		packageName, ok := cfg.PackageNameByGroup[s.Group]
		if !ok || packageName == "" {
			return nil, fmt.Errorf("shared types package name not found for group %q", s.Group)
		}
		info.ImportPath = importPath
		info.PackageName = packageName
	}

	resultFields, err := buildResultFields(s, info.EmbeddedTypeMap, info.NeedsImport, info.PackageName)
	if err != nil {
		return nil, err
	}
	info.ResultFields = resultFields

	return info, nil
}

func generateTableCode(s spec, outDir string, sharedTypesConfig *sharedTypesConfig) error {
	info, err := resolveSharedTypesInfo(s, sharedTypesConfig)
	if err != nil {
		return err
	}

	data := tableTemplateData{
		CopyrightHeader:     elasticCopyrightHeader,
		CodeGeneratedNotice: codeGeneratedNotice,
		SourceLine:          buildSourceLine("tables", s.sourceFile),
		BuildTagLine:        buildBuildTagLine(s.Platforms),
		PackageName:         toPackageName(s.Name),
		NeedsTimeImport:     info.NeedsTimeImport,
		NeedsSharedImport:   info.NeedsImport,
		SharedImport:        info.ImportPath,
		Name:                s.Name,
		Description:         s.Description,
		ResultFields:        info.ResultFields,
	}

	content, err := renderTemplate("table", "templates/table.tmpl", data)
	if err != nil {
		return err
	}

	// Create subdirectory for this table
	tableDir := filepath.Join(outDir, s.Name)
	if s.Group != "" {
		tableDir = filepath.Join(outDir, s.Group, s.Name)
	}
	if err := os.MkdirAll(tableDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", tableDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(tableDir, s.Name+".go")
	return writeFile(filename, content)
}

// embeddedTypeName returns the name of the embedded/shared type for a column, or empty if not embedded.
func embeddedTypeName(col columnSpec) string {
	if col.EmbeddedType != "" {
		return col.EmbeddedType
	}
	if col.SharedType != "" {
		return col.SharedType
	}
	if col.Type == "EMBEDDED" && col.Name != "" {
		return col.Name
	}
	return ""
}

// generateDocumentation generates documentation for both tables and views.
// Customer-facing docs show flattened columns only (embedded types are expanded to their constituent columns).
func generateDocumentation(s spec, docsDir string) error {
	// Build a map of shared types for quick lookup
	embeddedTypeMap := make(map[string]sharedTypeSpec)
	for _, et := range s.EmbeddedTypes {
		embeddedTypeMap[et.Name] = et
	}

	var schemaRows []schemaRow
	for _, col := range s.Columns {
		typeName := embeddedTypeName(col)
		if typeName != "" {
			if et, ok := embeddedTypeMap[typeName]; ok {
				// Expand to flattened columns so docs match what users see in queries (e.g. application_name, username).
				for _, embeddedCol := range et.Columns {
					schemaRows = append(schemaRows, schemaRow{
						Name:        embeddedCol.Name,
						Type:        embeddedCol.Type,
						Description: embeddedCol.Description,
					})
				}
				continue
			}
		}
		// Regular column (or unknown embedded type — show as-is)
		schemaRows = append(schemaRows, schemaRow{
			Name:        col.Name,
			Type:        col.Type,
			Description: col.Description,
		})
	}

	var platformLines []string
	platformMap := map[string]bool{
		"linux":   false,
		"darwin":  false,
		"windows": false,
	}
	for _, p := range s.Platforms {
		platformMap[p] = true
	}
	platformLines = append(platformLines, fmt.Sprintf("%s Linux", checkmark(platformMap["linux"])))
	platformLines = append(platformLines, fmt.Sprintf("%s macOS", checkmark(platformMap["darwin"])))
	platformLines = append(platformLines, fmt.Sprintf("%s Windows", checkmark(platformMap["windows"])))

	longDescription := strings.TrimSpace(s.Documentation.Description)
	viewDefinition := ""
	if s.Type == "view" {
		viewDefinition = fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
	}

	examples := make([]exampleQuery, 0, len(s.Documentation.Examples))
	for _, example := range s.Documentation.Examples {
		examples = append(examples, exampleQuery{
			Title: example.Title,
			Query: strings.TrimSpace(example.Query),
		})
	}

	data := docTemplateData{
		Name:            s.Name,
		Description:     s.Description,
		PlatformLines:   platformLines,
		LongDescription: longDescription,
		SchemaRows:      schemaRows,
		IsView:          s.Type == "view",
		RequiredTables:  s.RequiredTables,
		ViewDefinition:  viewDefinition,
		CodeFence:       "```",
		CodeQuote:       "`",
		Examples:        examples,
		Notes:           s.Documentation.Notes,
		RelatedTables:   s.Documentation.RelatedTables,
	}

	content, err := renderTemplate("docs", "templates/docs.tmpl", data)
	if err != nil {
		return err
	}

	filename := filepath.Join(docsDir, s.Name+".md")
	return writeFile(filename, content)
}

// osqueryTypeToGoType maps osquery column types to Go types for result structs
func osqueryTypeToGoType(col columnSpec) string {
	// If explicit go_type is specified, use it
	if col.GoType != "" {
		return col.GoType
	}

	// Otherwise use default mapping based on osquery type
	switch col.Type {
	case "TEXT":
		return "string"
	case "INTEGER":
		return "int32"
	case "BIGINT":
		return "int64"
	case "DOUBLE":
		return "float64"
	case "BOOLEAN", "BOOL":
		return "bool"
	default:
		return "string" // Default fallback
	}
}

// buildStructTag builds the osquery struct tag with optional format and timezone
func buildStructTag(col columnSpec) string {
	var parts []string

	// Always include the column name
	parts = append(parts, fmt.Sprintf(`osquery:"%s"`, col.Name))

	// Add format if specified
	if col.Format != "" {
		parts = append(parts, fmt.Sprintf(`format:"%s"`, col.Format))
	}

	// Add timezone if specified
	if col.Timezone != "" {
		parts = append(parts, fmt.Sprintf(`tz:"%s"`, col.Timezone))
	}

	return "`" + strings.Join(parts, " ") + "`"
}

// generateSharedTypesPackage generates a Go package with all shared type definitions
func generateSharedTypesPackage(types []sharedTypeSpec, packageName, outDir string) error {
	if len(types) == 0 {
		return nil
	}

	// Sort types by name for deterministic output.
	sort.Slice(types, func(i, j int) bool { return types[i].Name < types[j].Name })

	needsTimeImport := false
	for _, et := range types {
		for _, col := range et.Columns {
			if osqueryTypeToGoType(col) == "time.Time" {
				needsTimeImport = true
				break
			}
		}
		if needsTimeImport {
			break
		}
	}

	sharedTypes := make([]sharedTypeTemplate, 0, len(types))
	for _, et := range types {
		fields := make([]structField, 0, len(et.Columns))
		for _, col := range et.Columns {
			fields = append(fields, structField{
				Name:        toTitleCase(col.Name),
				Type:        osqueryTypeToGoType(col),
				Tag:         buildStructTag(col),
				Description: col.Description,
			})
		}
		sharedTypes = append(sharedTypes, sharedTypeTemplate{
			Name:        et.Name,
			Description: et.Description,
			Fields:      fields,
		})
	}

	data := sharedTypesTemplateData{
		CopyrightHeader:     elasticCopyrightHeader,
		CodeGeneratedNotice: codeGeneratedNotice,
		PackageName:         packageName,
		NeedsTimeImport:     needsTimeImport,
		Types:               sharedTypes,
	}

	content, err := renderTemplate("sharedTypes", "templates/shared_types.tmpl", data)
	if err != nil {
		return err
	}

	// Create output directory
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create shared types directory %s: %w", outDir, err)
	}

	// Write to file
	filename := filepath.Join(outDir, "types.go")
	return writeFile(filename, content)
}

func resolveSharedTypesOutput(outDir, group, moduleDir, modulePath string) (string, string, error) {
	absOutDir, err := filepath.Abs(outDir)
	if err != nil {
		return "", "", fmt.Errorf("failed to resolve output directory: %w", err)
	}
	if moduleDir == "" || modulePath == "" {
		return "", "", fmt.Errorf("module info is required to resolve shared types output")
	}
	if group == "" {
		return "", "", fmt.Errorf("shared types require a group")
	}

	rel, err := filepath.Rel(moduleDir, absOutDir)
	if err != nil {
		return "", "", fmt.Errorf("failed to resolve output directory relative to module: %w", err)
	}
	if strings.HasPrefix(rel, "..") {
		return "", "", fmt.Errorf("output directory %s is outside module %s", absOutDir, moduleDir)
	}

	sharedDir := filepath.Join(absOutDir, group)
	relImport := path.Clean(filepath.ToSlash(filepath.Join(rel, group)))
	importPath := modulePath + "/" + relImport
	return sharedDir, importPath, nil
}

func mergeSharedTypesFiles(files []sharedTypesFile) (*sharedTypesConfig, error) {
	merged := &sharedTypesConfig{
		TypesByGroup: make(map[string]map[string]sharedTypeSpec),
	}
	typeNamesByGroup := make(map[string]map[string]bool)

	for _, file := range files {
		if len(file.Types) == 0 {
			continue
		}
		if file.Group == "" {
			return nil, fmt.Errorf("%s: shared types require 'group' to be set", file.sourceFile)
		}

		group := file.Group
		if _, ok := merged.TypesByGroup[group]; !ok {
			merged.TypesByGroup[group] = make(map[string]sharedTypeSpec)
		}
		if _, ok := typeNamesByGroup[group]; !ok {
			typeNamesByGroup[group] = make(map[string]bool)
		}

		for _, t := range file.Types {
			if typeNamesByGroup[group][t.Name] {
				return nil, fmt.Errorf("shared type %q is defined multiple times in group %q", t.Name, group)
			}
			typeNamesByGroup[group][t.Name] = true
			merged.TypesByGroup[group][t.Name] = t
		}
	}

	return merged, nil
}

func findGoModDir(startDir string) (string, error) {
	dir := startDir
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("could not find go.mod starting from %s", startDir)
		}
		dir = parent
	}
}

func getModulePath(moduleDir string) (string, error) {
	cmd := exec.Command("go", "list", "-m", "-f", "{{.Path}}")
	cmd.Dir = moduleDir
	modulePathBytes, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to resolve module path from %s: %w", moduleDir, err)
	}
	return strings.TrimSpace(string(modulePathBytes)), nil
}

func buildSharedTypesForGroup(typesByGroup map[string]map[string]sharedTypeSpec, group string) []sharedTypeSpec {
	var combined []sharedTypeSpec
	if group == "" {
		return combined
	}
	if scoped, ok := typesByGroup[group]; ok {
		for _, t := range scoped {
			combined = append(combined, t)
		}
	}
	sort.Slice(combined, func(i, j int) bool { return combined[i].Name < combined[j].Name })
	return combined
}

func collectSharedTypesGroups(specs []spec) map[string]bool {
	groups := make(map[string]bool)
	for _, s := range specs {
		if len(s.SharedTypes) == 0 {
			continue
		}
		groups[s.Group] = true
	}
	return groups
}

func generateSharedTypesPackages(cfg *sharedTypesConfig, outDir string, specs []spec) error {
	if cfg == nil {
		return nil
	}
	if len(cfg.TypesByGroup) == 0 {
		return nil
	}

	groupSet := collectSharedTypesGroups(specs)
	if len(groupSet) == 0 {
		return nil
	}

	groups := make([]string, 0, len(groupSet))
	for g := range groupSet {
		groups = append(groups, g)
	}
	sort.Strings(groups)

	absOutDir, err := filepath.Abs(outDir)
	if err != nil {
		return fmt.Errorf("failed to resolve output directory: %w", err)
	}
	moduleDir, err := findGoModDir(absOutDir)
	if err != nil {
		return err
	}
	modulePath, err := getModulePath(moduleDir)
	if err != nil {
		return err
	}

	cfg.ImportPathByGroup = make(map[string]string)
	cfg.PackageNameByGroup = make(map[string]string)

	for _, group := range groups {
		types := buildSharedTypesForGroup(cfg.TypesByGroup, group)
		if len(types) == 0 {
			return fmt.Errorf("shared types requested for group %q but no shared types are defined", group)
		}

		sharedDir, importPath, err := resolveSharedTypesOutput(outDir, group, moduleDir, modulePath)
		if err != nil {
			return err
		}
		if err := os.MkdirAll(sharedDir, 0755); err != nil {
			return fmt.Errorf("failed to create shared types directory: %w", err)
		}
		packageName := toPackageName(group)
		if err := generateSharedTypesPackage(types, packageName, sharedDir); err != nil {
			return err
		}
		cfg.ImportPathByGroup[group] = importPath
		cfg.PackageNameByGroup[group] = packageName
	}

	if *verbose {
		fmt.Printf("Generated shared types packages for %d group(s)\n", len(groupSet))
	}
	return nil
}

// toPackageName converts a table/view name to an idiomatic Go package name
// (lowercase without underscores)
func toPackageName(name string) string {
	// Remove underscores and convert to lowercase
	return strings.ReplaceAll(strings.ToLower(name), "_", "")
}

func toTitleCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English).String(parts[i])
	}
	return strings.Join(parts, "")
}

func checkmark(enabled bool) string {
	if enabled {
		return "✅"
	}
	return "❌"
}

func containsAll(slice []string, items []string) bool {
	m := make(map[string]bool)
	for _, s := range slice {
		m[s] = true
	}
	for _, item := range items {
		if !m[item] {
			return false
		}
	}
	return true
}

// writeFile writes content to a file with standard permissions.
func writeFile(filename string, content string) error {
	return os.WriteFile(filename, []byte(content), 0644)
}

func generateViewCode(s spec, outDir string, sharedTypesConfig *sharedTypesConfig) error {
	info, err := resolveSharedTypesInfo(s, sharedTypesConfig)
	if err != nil {
		return err
	}

	columnsComment := make([]string, 0, len(s.Columns))
	for _, col := range s.Columns {
		columnsComment = append(columnsComment, fmt.Sprintf("%s (%s): %s", col.Name, col.Type, col.Description))
	}

	requiredTables := "[]string{}"
	if len(s.RequiredTables) > 0 {
		quoted := make([]string, 0, len(s.RequiredTables))
		for _, table := range s.RequiredTables {
			quoted = append(quoted, fmt.Sprintf("%q", table))
		}
		requiredTables = "[]string{" + strings.Join(quoted, ", ") + "}"
	}

	viewSQL := fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
	viewSQLLiteral := "`" + viewSQL + "`"

	data := viewTemplateData{
		CopyrightHeader:     elasticCopyrightHeader,
		CodeGeneratedNotice: codeGeneratedNotice,
		SourceLine:          buildSourceLine("views", s.sourceFile),
		BuildTagLine:        buildBuildTagLine(s.Platforms),
		PackageName:         toPackageName(s.Name),
		NeedsTimeImport:     info.NeedsTimeImport,
		NeedsSharedImport:   info.NeedsImport,
		SharedImport:        info.ImportPath,
		Name:                s.Name,
		HookName:            "Create" + toTitleCase(s.Name) + "View",
		Description:         s.Description,
		ResultFields:        info.ResultFields,
		ColumnsComment:      columnsComment,
		RequiredTables:      requiredTables,
		ViewSQL:             viewSQLLiteral,
	}

	content, err := renderTemplate("view", "templates/view.tmpl", data)
	if err != nil {
		return err
	}

	// Create subdirectory for this view
	viewDir := filepath.Join(outDir, s.Name)
	if s.Group != "" {
		viewDir = filepath.Join(outDir, s.Group, s.Name)
	}
	if err := os.MkdirAll(viewDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", viewDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(viewDir, s.Name+".go")
	return writeFile(filename, content)
}

// formatGeneratedFiles runs goimports and gofmt on all generated Go files.
func formatGeneratedFiles(dirs ...string) error {
	for _, dir := range dirs {
		var files []string

		// Recursively find all .go files
		err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && filepath.Ext(path) == ".go" {
				files = append(files, path)
			}
			return nil
		})
		if err != nil {
			return fmt.Errorf("failed to walk directory %s: %w", dir, err)
		}

		if len(files) == 0 {
			continue
		}

		// Run goimports
		cmd := exec.Command("goimports", append([]string{"-w"}, files...)...)
		if _, err := cmd.CombinedOutput(); err != nil {
			// If goimports is not installed, try using go run
			cmd = exec.Command("go", append([]string{"run", "golang.org/x/tools/cmd/goimports@latest", "-w"}, files...)...)
			if output, err := cmd.CombinedOutput(); err != nil {
				return fmt.Errorf("failed to run goimports on %s: %w\n%s", dir, err, output)
			}
		}

		// Run gofmt
		cmd = exec.Command("gofmt", append([]string{"-w"}, files...)...)
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to run gofmt on %s: %w\n%s", dir, err, output)
		}
	}

	return nil
}

// generateStaticTablesRegistry generates platform-specific static registry files with table specs
func generateStaticTablesRegistry(tableSpecs []spec, outDir string) error {
	// Group tables by platform
	platformTables := make(map[string][]spec)

	for _, s := range tableSpecs {
		for _, platform := range s.Platforms {
			platformTables[platform] = append(platformTables[platform], s)
		}
	}

	// Generate a registry file for each platform
	for _, platform := range []string{"linux", "darwin", "windows"} {
		tables := platformTables[platform]
		sort.Slice(tables, func(i, j int) bool { return tables[i].Name < tables[j].Name })

		header := elasticCopyrightHeader +
			codeGeneratedNotice +
			fmt.Sprintf("// Source: gentables - static registry of %s tables\n\n", platform) +
			fmt.Sprintf("//go:build %s\n\n", platform)

		data := tableRegistryData{
			Header:    header,
			HasTables: len(tables) > 0,
		}

		if len(tables) > 0 {
			implPackages := make(map[string]bool)
			for _, s := range tables {
				if s.ImplementationPackage != "" {
					implPackages[s.ImplementationPackage] = true
				}
			}
			implPkgList := make([]string, 0, len(implPackages))
			for pkg := range implPackages {
				implPkgList = append(implPkgList, pkg)
			}
			sort.Strings(implPkgList)
			data.ImplImports = implPkgList
			for _, s := range tables {
				pkgName := toPackageName(s.Name)
				importPath := fmt.Sprintf("github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/tables/generated/%s", s.Name)
				if s.Group != "" {
					importPath = fmt.Sprintf("github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/tables/generated/%s/%s", s.Group, s.Name)
				}
				data.TableImports = append(data.TableImports, importEntry{
					Alias: pkgName,
					Path:  importPath,
				})
				data.Entries = append(data.Entries, registryEntry{
					Name:         s.Name,
					Description:  s.Description,
					PackageAlias: pkgName,
				})
			}
		}

		content, err := renderTemplate("registryTables", "templates/registry_tables.tmpl", data)
		if err != nil {
			return err
		}
		filename := filepath.Join(outDir, fmt.Sprintf("registry_%s.go", platform))
		if err := writeFile(filename, content); err != nil {
			return err
		}
	}

	return nil
}

// generateStaticViewsRegistry generates platform-specific static registry files with view specs
func generateStaticViewsRegistry(viewSpecs []spec, outDir string) error {
	// Group views by platform
	platformViews := make(map[string][]spec)

	for _, s := range viewSpecs {
		for _, platform := range s.Platforms {
			platformViews[platform] = append(platformViews[platform], s)
		}
	}

	// Generate a registry file for each platform
	for _, platform := range []string{"linux", "darwin", "windows"} {
		views := platformViews[platform]
		sort.Slice(views, func(i, j int) bool { return views[i].Name < views[j].Name })

		header := elasticCopyrightHeader +
			codeGeneratedNotice +
			fmt.Sprintf("// Source: gentables - static registry of %s views\n\n", platform) +
			fmt.Sprintf("//go:build %s\n\n", platform)

		data := viewRegistryData{
			Header:   header,
			HasViews: len(views) > 0,
		}

		if len(views) > 0 {
			for _, s := range views {
				pkgName := toPackageName(s.Name)
				importPath := fmt.Sprintf("github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/views/generated/%s", s.Name)
				if s.Group != "" {
					importPath = fmt.Sprintf("github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/views/generated/%s/%s", s.Group, s.Name)
				}
				data.ViewImports = append(data.ViewImports, importEntry{
					Alias: pkgName,
					Path:  importPath,
				})
				data.Entries = append(data.Entries, registryEntry{
					Name:         s.Name,
					Description:  s.Description,
					PackageAlias: pkgName,
				})
			}
		}

		content, err := renderTemplate("registryViews", "templates/registry_views.tmpl", data)
		if err != nil {
			return err
		}
		filename := filepath.Join(outDir, fmt.Sprintf("registry_%s.go", platform))
		if err := writeFile(filename, content); err != nil {
			return err
		}
	}

	return nil
}

// validateViewColumns validates that the columns specified in the view spec
// match the columns in the SELECT statement.
// It uses TiDB parser to parse the SQL AST and extract column names.
func validateViewColumns(s spec) error {
	// Extract column names from the SELECT statement using SQL parser
	actualColumns, hasSelectStar, err := extractColumnsFromSelect(s.Query)
	if err != nil {
		return fmt.Errorf("failed to parse SELECT statement: %w", err)
	}

	// If query uses SELECT *, skip validation
	if hasSelectStar {
		if *verbose {
			fmt.Printf("Warning: view %s uses SELECT *, skipping column validation\n", s.Name)
		}
		return nil
	}

	// Check if any column has an error (missing alias)
	for _, col := range actualColumns {
		if strings.HasPrefix(col, "ERROR:") {
			return fmt.Errorf(col[7:]) // Remove "ERROR: " prefix
		}
	}

	// Build a map of specified column names
	specifiedColumns := make(map[string]bool)
	for _, col := range s.Columns {
		specifiedColumns[col.Name] = true
	}

	// Build a map of actual column names
	actualColumnMap := make(map[string]bool)
	for _, col := range actualColumns {
		actualColumnMap[col] = true
	}

	// Check if all specified columns exist in the SELECT output
	for _, col := range s.Columns {
		if !actualColumnMap[col.Name] {
			return fmt.Errorf("column %q is specified but not in SELECT output (actual columns: %v)",
				col.Name, actualColumns)
		}
	}

	// Check if all SELECT output columns are specified
	for _, col := range actualColumns {
		if !specifiedColumns[col] {
			return fmt.Errorf("column %q is in SELECT output but not specified in columns list", col)
		}
	}

	return nil
}

// validateDocumentation validates that required documentation fields are present.
func validateDocumentation(doc documentationConfig) error {
	if strings.TrimSpace(doc.Description) == "" {
		return fmt.Errorf("documentation.description is required")
	}
	if len(doc.Examples) == 0 {
		return fmt.Errorf("documentation.examples is required (at least one example must be provided)")
	}
	if len(doc.Notes) == 0 {
		return fmt.Errorf("documentation.notes is required (at least one note must be provided)")
	}
	return nil
}

// validateSpec validates a spec based on its type
func validateSpec(s spec) error {
	// Validate type field
	if s.Type != "table" && s.Type != "view" {
		return fmt.Errorf("type must be 'table' or 'view', got %q", s.Type)
	}

	// Validate columns are specified
	if len(s.Columns) == 0 {
		return fmt.Errorf("must specify at least one column")
	}

	// Validate documentation (same requirements for both tables and views)
	if err := validateDocumentation(s.Documentation); err != nil {
		return err
	}

	// Type-specific validation
	switch s.Type {
	case "table":
		// Tables must not have query field
		if strings.TrimSpace(s.Query) != "" {
			return fmt.Errorf("query field is only valid for views, not tables")
		}
		// Every table must declare its implementation package for registration
		if strings.TrimSpace(s.ImplementationPackage) == "" {
			return fmt.Errorf("tables must specify implementation_package (the import path of the package that registers this table via RegisterGenerateFunc)")
		}

	case "view":
		// Views must have query field
		if strings.TrimSpace(s.Query) == "" {
			return fmt.Errorf("views must specify a query")
		}
		// Validate that columns match the SELECT statement
		if err := validateViewColumns(s); err != nil {
			return fmt.Errorf("column validation failed: %w", err)
		}
	}

	return nil
}

// extractColumnsFromSelect uses TiDB parser to extract column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func extractColumnsFromSelect(query string) ([]string, bool, error) {
	p := parser.New()

	// Remove trailing semicolon if present
	query = strings.TrimSpace(query)
	query = strings.TrimSuffix(query, ";")

	stmtNodes, _, err := p.Parse(query, "", "")
	if err != nil {
		return nil, false, fmt.Errorf("SQL parse error: %w", err)
	}

	if len(stmtNodes) == 0 {
		return nil, false, fmt.Errorf("no SQL statement found")
	}

	columns, hasWildcard := extractFinalColumnNames(stmtNodes[0])
	if len(columns) == 0 {
		return nil, false, fmt.Errorf("no columns found in SELECT statement")
	}

	return columns, hasWildcard, nil
}

// extractFinalColumnNames traverses the AST and returns the final column names
// and whether a wildcard (*) was encountered.
func extractFinalColumnNames(node ast.Node) ([]string, bool) {
	switch x := node.(type) {
	case *ast.SelectStmt:
		return getColumnNamesFromSelect(x)

	case *ast.UnionStmt:
		// Handles UNION / UNION ALL
		// The SQL standard dictates that the column names of a UNION
		// are determined by the first (left-most) SELECT in the chain.
		if x.SelectList != nil && len(x.SelectList.Selects) > 0 {
			return getColumnNamesFromSelect(x.SelectList.Selects[0])
		}
	}

	return []string{}, false
}

// getColumnNamesFromSelect extracts column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func getColumnNamesFromSelect(stmt *ast.SelectStmt) ([]string, bool) {
	var names []string
	hasWildcard := false

	for _, field := range stmt.Fields.Fields {
		// 1. If there is an explicit ALIAS (AS ...), that is the final name.
		if field.AsName.O != "" {
			names = append(names, field.AsName.O)
			continue
		}

		// 2. Handle Wildcards (*)
		if field.WildCard != nil {
			hasWildcard = true
			if field.WildCard.Table.O != "" {
				names = append(names, field.WildCard.Table.O+".*")
			} else {
				names = append(names, "*")
			}
			continue
		}

		// 3. No Alias? Only simple column references are allowed without an alias.
		if colExpr, ok := field.Expr.(*ast.ColumnNameExpr); ok {
			// Case: SELECT t.my_col -> Final name is "my_col"
			names = append(names, colExpr.Name.Name.O)
		} else {
			// Case: Complex expressions (functions, CASE, operators, etc.) require an alias
			var sb strings.Builder
			ctx := format.NewRestoreCtx(format.DefaultRestoreFlags, &sb)
			if err := field.Expr.Restore(ctx); err == nil {
				names = append(names, fmt.Sprintf("ERROR: expression '%s' requires an AS alias", sb.String()))
			} else {
				names = append(names, "ERROR: complex expression requires an AS alias")
			}
		}
	}

	return names, hasWildcard
}
