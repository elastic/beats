// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

//go:generate go run . -verbose

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/pingcap/parser"
	"github.com/pingcap/parser/ast"
	"github.com/pingcap/parser/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	// test_driver is required for the parser to work. It registers the AST node constructors
	// via init(). Without it, parser.New() will panic with "no parser driver".
	// See: https://github.com/pingcap/parser/issues/43
	_ "github.com/pingcap/parser/test_driver"

	"gopkg.in/yaml.v3"
)

// spec represents a unified specification for both tables and views
type spec struct {
	Type                  string              `yaml:"type"` // "table" or "view"
	Name                  string              `yaml:"name"`
	Description           string              `yaml:"description"`
	Platforms             []string            `yaml:"platforms"`
	Columns               []columnSpec        `yaml:"columns"`
	Documentation         documentationConfig `yaml:"documentation"`
	ImplementationPackage string              `yaml:"implementation_package,omitempty"`

	// View-specific fields
	Query          string   `yaml:"query,omitempty"`
	RequiredTables []string `yaml:"required_tables,omitempty"`
}

type columnSpec struct {
	Name        string `yaml:"name"`
	Type        string `yaml:"type"`
	Description string `yaml:"description"`
	Format      string `yaml:"format,omitempty"`   // Optional: "unix", "rfc3339"
	Timezone    string `yaml:"timezone,omitempty"` // Optional: "UTC", etc.
	GoType      string `yaml:"go_type,omitempty"`  // Optional: explicit Go type override (e.g., "time.Time")
}

type documentationConfig struct {
	Description   string         `yaml:"description"` // Optional for tables, required for views
	Examples      []exampleQuery `yaml:"examples"`
	Notes         []string       `yaml:"notes"`
	RelatedTables []string       `yaml:"related_tables"` // Optional
}

type exampleQuery struct {
	Title string `yaml:"title"`
	Query string `yaml:"query"`
}

const (
	elasticCopyrightHeader = `// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

`
	codeGeneratedNotice = "// Code generated by gentables. DO NOT EDIT.\n"
)

var (
	specDir  = flag.String("spec-dir", "../../specs", "Directory containing YAML specifications (tables and views)")
	outDir   = flag.String("out-dir", "../../pkg/tables/generated", "Output directory for generated table Go files")
	viewsOut = flag.String("views-out-dir", "../../pkg/views/generated", "Output directory for generated view Go files")
	docsDir  = flag.String("docs-dir", "../../docs/tables", "Output directory for generated table documentation")
	viewsDoc = flag.String("views-docs-dir", "../../docs/views", "Output directory for generated view documentation")
	verbose  = flag.Bool("verbose", false, "Verbose output")
)

func main() {
	flag.Parse()

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Load all YAML spec files
	specs, err := loadSpecs(*specDir)
	if err != nil {
		return fmt.Errorf("failed to load specs: %w", err)
	}

	if *verbose {
		tableCount := 0
		viewCount := 0
		for _, s := range specs {
			switch s.Type {
			case "table":
				tableCount++
			case "view":
				viewCount++
			}
		}
		fmt.Printf("Loaded %d specifications (%d tables, %d views)\n", len(specs), tableCount, viewCount)
	}

	// Create output directories
	if err := os.MkdirAll(*outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	if err := os.MkdirAll(*docsDir, 0755); err != nil {
		return fmt.Errorf("failed to create docs directory: %w", err)
	}
	if err := os.MkdirAll(*viewsOut, 0755); err != nil {
		return fmt.Errorf("failed to create views output directory: %w", err)
	}
	if err := os.MkdirAll(*viewsDoc, 0755); err != nil {
		return fmt.Errorf("failed to create views docs directory: %w", err)
	}

	var tableSpecs, viewSpecs []spec

	// Generate code and documentation for each spec
	for _, s := range specs {
		if *verbose {
			fmt.Printf("Processing %s: %s\n", s.Type, s.Name)
		}

		// Validate the spec based on type
		if err := validateSpec(s); err != nil {
			return fmt.Errorf("%s %s: %w", s.Type, s.Name, err)
		}

		// Route to appropriate generator based on type
		switch s.Type {
		case "table":
			tableSpecs = append(tableSpecs, s)
			// Generate Go code
			if err := generateTableCode(s, *outDir); err != nil {
				return fmt.Errorf("failed to generate code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *docsDir); err != nil {
				return fmt.Errorf("failed to generate docs for %s: %w", s.Name, err)
			}

		case "view":
			viewSpecs = append(viewSpecs, s)
			// Generate Go code
			if err := generateViewCode(s, *viewsOut); err != nil {
				return fmt.Errorf("failed to generate view code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *viewsDoc); err != nil {
				return fmt.Errorf("failed to generate view docs for %s: %w", s.Name, err)
			}

		default:
			return fmt.Errorf("spec %s has invalid type: %q (must be 'table' or 'view')", s.Name, s.Type)
		}
	}

	// Note: registry files are now static and not generated
	// They live in pkg/tables/registry.go and pkg/views/registry.go

	// Generate platform-specific import files
	if err := generatePlatformImports(tableSpecs, viewSpecs, *outDir, *viewsOut); err != nil {
		return fmt.Errorf("failed to generate platform imports: %w", err)
	}

	if *verbose {
		fmt.Println("Code generation completed successfully")
		fmt.Println("Formatting generated code...")
	}

	// Format all generated Go files
	if err := formatGeneratedFiles(*outDir, *viewsOut); err != nil {
		return fmt.Errorf("failed to format generated files: %w", err)
	}

	if *verbose {
		fmt.Println("Formatting completed successfully")
	}

	return nil
}

func loadSpecs(dir string) ([]spec, error) {
	pattern := filepath.Join(dir, "*.yaml")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return nil, err
	}

	var specs []spec
	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			return nil, fmt.Errorf("failed to read %s: %w", file, err)
		}

		var s spec
		if err := yaml.Unmarshal(data, &s); err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", file, err)
		}

		applyDefaults(&s)
		specs = append(specs, s)
	}

	return specs, nil
}

// applyTableDefaults applies sensible defaults to table spec fields
// applyDefaults applies sensible defaults to spec fields
func applyDefaults(s *spec) {
	// Default to all platforms if not specified
	if len(s.Platforms) == 0 {
		s.Platforms = []string{"linux", "darwin", "windows"}
	}

	// Ensure RelatedTables is not nil
	if s.Documentation.RelatedTables == nil {
		s.Documentation.RelatedTables = []string{}
	}
}

func generateTableCode(s spec, outDir string) error {
	var b strings.Builder

	writeGoFileHeader(&b, toPackageName(s.Name), "tables", s.Name, s.Platforms)

	// Check if we need to import time package
	needsTimeImport := false
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		if goType == "time.Time" {
			needsTimeImport = true
			break
		}
	}

	// Generate imports
	b.WriteString("import (\n")
	b.WriteString("\t\"context\"\n")
	b.WriteString("\t\"errors\"\n")
	b.WriteString("\t\"sync\"\n")
	if needsTimeImport {
		b.WriteString("\t\"time\"\n")
	}
	b.WriteString("\n")
	b.WriteString("\t\"github.com/osquery/osquery-go/plugin/table\"\n")
	b.WriteString("\n")
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/encoding\"\n")
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/logger\"\n")
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/tables\"\n")
	b.WriteString(")\n\n")

	// Generate generate function registration
	b.WriteString("var (\n")
	b.WriteString("\tgenerateFunc func(context.Context, table.QueryContext, *logger.Logger) ([]Result, error)\n")
	b.WriteString("\tregisterOnce sync.Once\n")
	b.WriteString(")\n\n")

	b.WriteString("// RegisterGenerateFunc registers the generate function for this table.\n")
	b.WriteString("// This should be called once from the implementation package's init() function.\n")
	b.WriteString("func RegisterGenerateFunc(f func(context.Context, table.QueryContext, *logger.Logger) ([]Result, error)) {\n")
	b.WriteString("\tregisterOnce.Do(func() {\n")
	b.WriteString("\t\tgenerateFunc = f\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n\n")

	b.WriteString("// GetGenerateFunc returns the osquery table.GenerateFunc for this table.\n")
	b.WriteString("// It wraps the registered generate function and handles marshaling of results.\n")
	b.WriteString("func GetGenerateFunc(log *logger.Logger) (table.GenerateFunc, error) {\n")
	b.WriteString("\tif generateFunc == nil {\n")
	fmt.Fprintf(&b, "\t\treturn nil, errors.New(\"generate function not registered for %s\")\n", s.Name)
	b.WriteString("\t}\n")
	b.WriteString("\treturn func(ctx context.Context, queryContext table.QueryContext) ([]map[string]string, error) {\n")
	b.WriteString("\t\tresults, err := generateFunc(ctx, queryContext, log)\n")
	b.WriteString("\t\tif err != nil {\n")
	b.WriteString("\t\t\treturn nil, err\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t\t\n")
	b.WriteString("\t\t// Convert results to maps\n")
	b.WriteString("\t\trows := make([]map[string]string, len(results))\n")
	b.WriteString("\t\tfor i, result := range results {\n")
	b.WriteString("\t\t\trow, err := encoding.MarshalToMap(result)\n")
	b.WriteString("\t\t\tif err != nil {\n")
	b.WriteString("\t\t\t\treturn nil, err\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\t\trows[i] = row\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t\treturn rows, nil\n")
	b.WriteString("\t}, nil\n")
	b.WriteString("}\n\n")

	// Generate result struct
	fmt.Fprintf(&b, "// Result represents a row from the %s table.\n", s.Name)
	b.WriteString("type Result struct {\n")

	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		fieldName := toGoFieldName(col.Name)
		structTag := buildStructTag(col)
		fmt.Fprintf(&b, "\t%s %s %s // %s\n", fieldName, goType, structTag, col.Description)
	}
	b.WriteString("}\n\n")

	// Generate column function
	fmt.Fprintf(&b, "// Columns returns the column definitions for the %s table.\n", s.Name)
	fmt.Fprintf(&b, "// %s\n", s.Description)
	b.WriteString("func Columns() []table.ColumnDefinition {\n")
	b.WriteString("\t// Generate column definitions automatically from the Result struct using reflection.\n")
	b.WriteString("\t// This ensures the columns always match the struct definition and prevents drift.\n")
	b.WriteString("\tcolumns, err := encoding.GenerateColumnDefinitions(Result{})\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\t// This should never happen in practice since we control the struct definition,\n")
	b.WriteString("\t\t// but if it does, panic to catch it during development/testing.\n")
	fmt.Fprintf(&b, "\t\tpanic(\"failed to generate %s columns: \" + err.Error())\n", s.Name)
	b.WriteString("\t}\n")
	b.WriteString("\treturn columns\n")
	b.WriteString("}\n\n")

	// Generate table metadata
	fmt.Fprintf(&b, "// TableName is the name of the %s table.\n", s.Name)
	fmt.Fprintf(&b, "const TableName = \"%s\"\n\n", s.Name)

	// Generate init function to register table spec
	b.WriteString("func init() {\n")
	b.WriteString("\ttables.RegisterTableSpec(tables.TableSpec{\n")
	fmt.Fprintf(&b, "\t\tName:         \"%s\",\n", s.Name)
	fmt.Fprintf(&b, "\t\tDescription:  \"%s\",\n", strings.ReplaceAll(s.Description, "\"", "\\\""))
	b.WriteString("\t\tPlatforms:    []string{")
	for i, p := range s.Platforms {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(&b, "\"%s\"", p)
	}
	b.WriteString("},\n")
	b.WriteString("\t\tTableName:    TableName,\n")
	b.WriteString("\t\tColumns:      Columns,\n")
	b.WriteString("\t\tGenerateFunc: GetGenerateFunc,\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n")

	// Create subdirectory for this table
	tableDir := filepath.Join(outDir, s.Name)
	if err := os.MkdirAll(tableDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", tableDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(tableDir, s.Name+".go")
	return writeFile(filename, b.String())
}

// generateDocumentation generates documentation for both tables and views
func generateDocumentation(s spec, docsDir string) error {
	var b strings.Builder

	writeDocumentationHeader(&b, s.Name, s.Description, s.Platforms)

	// Additional detailed description (required for both tables and views)
	if s.Documentation.Description != "" {
		b.WriteString("## Description\n\n")
		b.WriteString(strings.TrimSpace(s.Documentation.Description) + "\n\n")
	}

	// Schema
	b.WriteString("## Schema\n\n")
	b.WriteString("| Column | Type | Description |\n")
	b.WriteString("|--------|------|-------------|\n")
	for _, col := range s.Columns {
		fmt.Fprintf(&b, "| `%s` | `%s` | %s |\n",
			col.Name, col.Type, col.Description)
	}
	b.WriteString("\n")

	// Required tables (views only)
	if s.Type == "view" && len(s.RequiredTables) > 0 {
		b.WriteString("## Required Tables\n\n")
		b.WriteString("This view requires the following tables to be available:\n\n")
		for _, table := range s.RequiredTables {
			b.WriteString("- `" + table + "`\n")
		}
		b.WriteString("\n")
	}

	// View definition (views only)
	if s.Type == "view" {
		b.WriteString("## View Definition\n\n")
		b.WriteString("```sql\n")
		createViewSQL := fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
		b.WriteString(createViewSQL + "\n")
		b.WriteString("```\n\n")
	}

	writeExamplesSection(&b, s.Documentation.Examples)
	writeNotesSection(&b, s.Documentation.Notes)

	// Related tables
	if len(s.Documentation.RelatedTables) > 0 {
		b.WriteString("## Related Tables\n\n")
		for _, table := range s.Documentation.RelatedTables {
			b.WriteString("- `" + table + "`\n")
		}
		b.WriteString("\n")
	}

	filename := filepath.Join(docsDir, s.Name+".md")
	return writeFile(filename, b.String())
}

func osqueryTypeToGoMethod(osqueryType string) string {
	switch osqueryType {
	case "TEXT":
		return "TextColumn"
	case "INTEGER":
		return "IntegerColumn"
	case "BIGINT":
		return "BigIntColumn"
	case "DOUBLE":
		return "DoubleColumn"
	default:
		return "TextColumn" // Default fallback
	}
}

// osqueryTypeToGoType maps osquery column types to Go types for result structs
func osqueryTypeToGoType(col columnSpec) string {
	// If explicit go_type is specified, use it
	if col.GoType != "" {
		return col.GoType
	}

	// Otherwise use default mapping based on osquery type
	switch col.Type {
	case "TEXT":
		return "string"
	case "INTEGER":
		return "int32"
	case "BIGINT":
		return "int64"
	case "DOUBLE":
		return "float64"
	default:
		return "string" // Default fallback
	}
}

// toGoFieldName converts snake_case to CamelCase for Go struct field names
func toGoFieldName(snakeCase string) string {
	return toCamelCase(snakeCase)
}

// buildStructTag builds the osquery struct tag with optional format and timezone
func buildStructTag(col columnSpec) string {
	var parts []string

	// Always include the column name
	parts = append(parts, fmt.Sprintf(`osquery:"%s"`, col.Name))

	// Add format if specified
	if col.Format != "" {
		parts = append(parts, fmt.Sprintf(`format:"%s"`, col.Format))
	}

	// Add timezone if specified
	if col.Timezone != "" {
		parts = append(parts, fmt.Sprintf(`tz:"%s"`, col.Timezone))
	}

	return "`" + strings.Join(parts, " ") + "`"
}

// toPackageName converts a table/view name to an idiomatic Go package name
// (lowercase without underscores)
func toPackageName(name string) string {
	// Remove underscores and convert to lowercase
	return strings.ReplaceAll(strings.ToLower(name), "_", "")
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English).String(parts[i])
	}
	return strings.Join(parts, "")
}

func checkmark(enabled bool) string {
	if enabled {
		return "✅"
	}
	return "❌"
}

func containsAll(slice []string, items []string) bool {
	m := make(map[string]bool)
	for _, s := range slice {
		m[s] = true
	}
	for _, item := range items {
		if !m[item] {
			return false
		}
	}
	return true
}

// writeGoFileHeader writes the common header for generated Go files.
func writeGoFileHeader(b *strings.Builder, packageName, sourceType, name string, platforms []string) {
	b.WriteString(elasticCopyrightHeader)
	b.WriteString(codeGeneratedNotice)
	fmt.Fprintf(b, "// Source: %s/%s.yaml\n\n", sourceType, name)

	// Build tags for platform-specific files
	if len(platforms) > 0 && !containsAll(platforms, []string{"linux", "darwin", "windows"}) {
		b.WriteString("//go:build " + strings.Join(platforms, " || ") + "\n\n")
	}

	fmt.Fprintf(b, "package %s\n\n", packageName)
}

// writeDocumentationHeader writes the common header for documentation files.
func writeDocumentationHeader(b *strings.Builder, name, description string, platforms []string) {
	// Title
	b.WriteString("# " + name + "\n\n")
	b.WriteString(description + "\n\n")

	// Platforms
	b.WriteString("## Platforms\n\n")
	platformMap := map[string]bool{
		"linux":   false,
		"darwin":  false,
		"windows": false,
	}
	for _, p := range platforms {
		platformMap[p] = true
	}
	fmt.Fprintf(b, "- %s Linux\n", checkmark(platformMap["linux"]))
	fmt.Fprintf(b, "- %s macOS\n", checkmark(platformMap["darwin"]))
	fmt.Fprintf(b, "- %s Windows\n\n", checkmark(platformMap["windows"]))
}

// writeExamplesSection writes the examples section for documentation.
func writeExamplesSection(b *strings.Builder, examples []exampleQuery) {
	if len(examples) > 0 {
		b.WriteString("## Examples\n\n")
		for _, example := range examples {
			b.WriteString("### " + example.Title + "\n\n")
			b.WriteString("```sql\n")
			b.WriteString(strings.TrimSpace(example.Query) + "\n")
			b.WriteString("```\n\n")
		}
	}
}

// writeNotesSection writes the notes section for documentation.
func writeNotesSection(b *strings.Builder, notes []string) {
	if len(notes) > 0 {
		b.WriteString("## Notes\n\n")
		for _, note := range notes {
			b.WriteString("- " + note + "\n")
		}
		b.WriteString("\n")
	}
}

// writeFile writes content to a file with standard permissions.
func writeFile(filename string, content string) error {
	return os.WriteFile(filename, []byte(content), 0644)
}

func generateViewCode(s spec, outDir string) error {
	var b strings.Builder

	writeGoFileHeader(&b, toPackageName(s.Name), "views", s.Name, s.Platforms)

	// Check if we need to import time package
	needsTimeImport := false
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		if goType == "time.Time" {
			needsTimeImport = true
			break
		}
	}

	// Generate imports
	b.WriteString("import (\n")
	b.WriteString("\t\"sync\"\n")
	if needsTimeImport {
		b.WriteString("\t\"time\"\n")
	}
	b.WriteString("\n")
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/hooks\"\n")
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/views\"\n")
	b.WriteString(")\n\n")

	// Generate hooks registration
	b.WriteString("var (\n")
	b.WriteString("\thooksFunc    func(*hooks.HookManager)\n")
	b.WriteString("\tregisterOnce sync.Once\n")
	b.WriteString(")\n\n")

	b.WriteString("// RegisterHooksFunc registers the hooks function for this view (optional).\n")
	b.WriteString("// This can be called to register any hooks that should be set up for this view.\n")
	b.WriteString("func RegisterHooksFunc(f func(*hooks.HookManager)){\n")
	b.WriteString("\tregisterOnce.Do(func() {\n")
	b.WriteString("\t\thooksFunc = f\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n\n")

	// Generate result struct
	fmt.Fprintf(&b, "// Result represents a row from the %s view.\n", s.Name)
	b.WriteString("type Result struct {\n")
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		fieldName := toGoFieldName(col.Name)
		structTag := buildStructTag(col)
		fmt.Fprintf(&b, "\t%s %s %s // %s\n", fieldName, goType, structTag, col.Description)
	}
	b.WriteString("}\n\n")

	// Generate default view function (as a reference/helper)
	fmt.Fprintf(&b, "// View returns the view definition for %s.\n", s.Name)
	fmt.Fprintf(&b, "// %s\n", s.Description)
	b.WriteString("//\n")
	b.WriteString("// Columns:\n")
	for _, col := range s.Columns {
		fmt.Fprintf(&b, "//   - %s (%s): %s\n", col.Name, col.Type, col.Description)
	}
	b.WriteString("func View() *hooks.View {\n")
	b.WriteString("\treturn hooks.NewView(\n")
	fmt.Fprintf(&b, "\t\t\"%s\",\n", s.Name)

	// Required tables
	b.WriteString("\t\t[]string{")
	for i, table := range s.RequiredTables {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("\"%s\"", table))
	}
	b.WriteString("},\n")

	// Generate the full CREATE VIEW statement from the SELECT query
	// The s.Query contains just the SELECT, we wrap it in CREATE VIEW
	createViewSQL := fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
	b.WriteString("\t\t`" + createViewSQL + "`,\n")
	b.WriteString("\t)\n")
	b.WriteString("}\n\n")

	// Generate init function to register view spec
	b.WriteString("func init() {\n")
	b.WriteString("\tviews.RegisterViewSpec(views.ViewSpec{\n")
	fmt.Fprintf(&b, "\t\tName:         \"%s\",\n", s.Name)
	fmt.Fprintf(&b, "\t\tDescription:  \"%s\",\n", strings.ReplaceAll(s.Description, "\"", "\\\""))
	b.WriteString("\t\tPlatforms:    []string{")
	for i, p := range s.Platforms {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(&b, "\"%s\"", p)
	}
	b.WriteString("},\n")
	b.WriteString("\t\tRequiredTables: []string{")
	for i, table := range s.RequiredTables {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(&b, "\"%s\"", table)
	}
	b.WriteString("},\n")
	b.WriteString("\t\tView:         View,\n")
	b.WriteString("\t\tHooksFunc:    hooksFunc,\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n")

	// Create subdirectory for this view
	viewDir := filepath.Join(outDir, s.Name)
	if err := os.MkdirAll(viewDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", viewDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(viewDir, s.Name+".go")
	return writeFile(filename, b.String())
}

// formatGeneratedFiles runs goimports and gofmt on all generated Go files.
func formatGeneratedFiles(dirs ...string) error {
	for _, dir := range dirs {
		var files []string

		// Recursively find all .go files
		err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && filepath.Ext(path) == ".go" {
				files = append(files, path)
			}
			return nil
		})
		if err != nil {
			return fmt.Errorf("failed to walk directory %s: %w", dir, err)
		}

		if len(files) == 0 {
			continue
		}

		// Run goimports
		cmd := exec.Command("goimports", append([]string{"-w"}, files...)...)
		if _, err := cmd.CombinedOutput(); err != nil {
			// If goimports is not installed, try using go run
			cmd = exec.Command("go", append([]string{"run", "golang.org/x/tools/cmd/goimports@latest", "-w"}, files...)...)
			if output, err := cmd.CombinedOutput(); err != nil {
				return fmt.Errorf("failed to run goimports on %s: %w\n%s", dir, err, output)
			}
		}

		// Run gofmt
		cmd = exec.Command("gofmt", append([]string{"-w"}, files...)...)
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to run gofmt on %s: %w\n%s", dir, err, output)
		}
	}

	return nil
}

// generatePlatformImports generates platform-specific files with naked imports
// for all tables and views that support each platform.
func generatePlatformImports(tableSpecs, viewSpecs []spec, tablesDir, viewsDir string) error {
	platforms := []string{"linux", "darwin", "windows"}

	// Convert output directories to import paths using go list
	tablesImportPath, err := getImportPath(tablesDir)
	if err != nil {
		return fmt.Errorf("failed to get import path for tables dir: %w", err)
	}

	viewsImportPath, err := getImportPath(viewsDir)
	if err != nil {
		return fmt.Errorf("failed to get import path for views dir: %w", err)
	}

	for _, platform := range platforms {
		if err := generatePlatformImportFile(tableSpecs, viewSpecs, tablesDir, tablesImportPath, viewsImportPath, platform); err != nil {
			return fmt.Errorf("failed to generate imports for %s: %w", platform, err)
		}
	}

	return nil
}

// generatePlatformImportFile generates a single platform-specific import file
func generatePlatformImportFile(tableSpecs, viewSpecs []spec, tablesDir, tablesImportPath, viewsImportPath, platform string) error {
	var b strings.Builder

	// Header
	b.WriteString(elasticCopyrightHeader)
	b.WriteString(codeGeneratedNotice)
	fmt.Fprintf(&b, "// Source: gentables - platform-specific imports for %s\n\n", platform)

	// Build tag
	fmt.Fprintf(&b, "//go:build %s\n\n", platform)

	// Package
	b.WriteString("package generated\n\n")

	// Imports section
	b.WriteString("import (\n")

	// Collect imports
	var implImports []string
	var tableImports []string
	var viewImports []string

	// Add implementation packages first (to trigger their init())
	for _, s := range tableSpecs {
		if containsPlatform(s.Platforms, platform) && s.ImplementationPackage != "" {
			implImports = append(implImports, s.ImplementationPackage)
		}
	}

	// Then collect generated tables (which register the table specs)
	for _, s := range tableSpecs {
		if containsPlatform(s.Platforms, platform) {
			tableImports = append(tableImports, fmt.Sprintf("%s/%s", tablesImportPath, s.Name))
		}
	}

	// Collect views that support this platform
	for _, s := range viewSpecs {
		if containsPlatform(s.Platforms, platform) {
			viewImports = append(viewImports, fmt.Sprintf("%s/%s", viewsImportPath, s.Name))
		}
	}

	// Write imports in correct order: impl, tables, views
	// Use blank lines to separate groups - gofmt will preserve groups while sorting within each
	for _, imp := range implImports {
		fmt.Fprintf(&b, "\t_ \"%s\"\n", imp)
	}
	if len(implImports) > 0 && (len(tableImports) > 0 || len(viewImports) > 0) {
		b.WriteString("\n")
	}
	
	for _, imp := range tableImports {
		fmt.Fprintf(&b, "\t_ \"%s\"\n", imp)
	}
	if len(tableImports) > 0 && len(viewImports) > 0 {
		b.WriteString("\n")
	}
	
	for _, imp := range viewImports {
		fmt.Fprintf(&b, "\t_ \"%s\"\n", imp)
	}

	b.WriteString(")\n")

	// Write to file
	filename := filepath.Join(tablesDir, fmt.Sprintf("tables_%s.go", platform))
	return writeFile(filename, b.String())
}

// containsPlatform checks if a platform is in the list of platforms
func containsPlatform(platforms []string, platform string) bool {
	for _, p := range platforms {
		if p == platform {
			return true
		}
	}
	return false
}

// getImportPath returns the Go import path for a directory using go list
func getImportPath(dir string) (string, error) {
	// Get absolute path
	absDir, err := filepath.Abs(dir)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path: %w", err)
	}

	// Ensure directory exists
	if err := os.MkdirAll(absDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create directory %s: %w", absDir, err)
	}

	// Try to use go list on the directory
	// We need to traverse up until we find a directory that go list can work with
	currentDir := absDir
	pathComponents := []string{}
	
	for {
		cmd := exec.Command("go", "list", "-f", "{{.ImportPath}}", ".")
		cmd.Dir = currentDir
		output, err := cmd.Output()
		
		if err == nil {
			// Success! Build the full import path
			baseImportPath := strings.TrimSpace(string(output))
			
			// Append any subdirectories we collected
			for i := len(pathComponents) - 1; i >= 0; i-- {
				baseImportPath = baseImportPath + "/" + pathComponents[i]
			}
			
			return baseImportPath, nil
		}
		
		// Move up one directory
		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			// Reached filesystem root without finding a valid Go package
			return "", fmt.Errorf("could not find Go module for directory %s", absDir)
		}
		
		// Remember this directory component
		pathComponents = append(pathComponents, filepath.Base(currentDir))
		currentDir = parentDir
	}
}

// validateViewColumns validates that the columns specified in the view spec
// match the columns in the SELECT statement.
// It uses TiDB parser to parse the SQL AST and extract column names.
func validateViewColumns(s spec) error {
	// Extract column names from the SELECT statement using SQL parser
	actualColumns, hasSelectStar, err := extractColumnsFromSelect(s.Query)
	if err != nil {
		return fmt.Errorf("failed to parse SELECT statement: %w", err)
	}

	// If query uses SELECT *, skip validation
	if hasSelectStar {
		if *verbose {
			fmt.Printf("Warning: view %s uses SELECT *, skipping column validation\n", s.Name)
		}
		return nil
	}

	// Check if any column has an error (missing alias)
	for _, col := range actualColumns {
		if strings.HasPrefix(col, "ERROR:") {
			return fmt.Errorf(col[7:]) // Remove "ERROR: " prefix
		}
	}

	// Build a map of specified column names
	specifiedColumns := make(map[string]bool)
	for _, col := range s.Columns {
		specifiedColumns[col.Name] = true
	}

	// Build a map of actual column names
	actualColumnMap := make(map[string]bool)
	for _, col := range actualColumns {
		actualColumnMap[col] = true
	}

	// Check if all specified columns exist in the SELECT output
	for _, col := range s.Columns {
		if !actualColumnMap[col.Name] {
			return fmt.Errorf("column %q is specified but not in SELECT output (actual columns: %v)",
				col.Name, actualColumns)
		}
	}

	// Check if all SELECT output columns are specified
	for _, col := range actualColumns {
		if !specifiedColumns[col] {
			return fmt.Errorf("column %q is in SELECT output but not specified in columns list", col)
		}
	}

	return nil
}

// validateDocumentation validates that required documentation fields are present.
func validateDocumentation(doc documentationConfig) error {
	if strings.TrimSpace(doc.Description) == "" {
		return fmt.Errorf("documentation.description is required")
	}
	if len(doc.Examples) == 0 {
		return fmt.Errorf("documentation.examples is required (at least one example must be provided)")
	}
	if len(doc.Notes) == 0 {
		return fmt.Errorf("documentation.notes is required (at least one note must be provided)")
	}
	return nil
}

// validateSpec validates a spec based on its type
func validateSpec(s spec) error {
	// Validate type field
	if s.Type != "table" && s.Type != "view" {
		return fmt.Errorf("type must be 'table' or 'view', got %q", s.Type)
	}

	// Validate columns are specified
	if len(s.Columns) == 0 {
		return fmt.Errorf("must specify at least one column")
	}

	// Validate documentation (same requirements for both tables and views)
	if err := validateDocumentation(s.Documentation); err != nil {
		return err
	}

	// Type-specific validation
	switch s.Type {
	case "table":
		// Tables must not have query field
		if strings.TrimSpace(s.Query) != "" {
			return fmt.Errorf("query field is only valid for views, not tables")
		}

	case "view":
		// Views must have query field
		if strings.TrimSpace(s.Query) == "" {
			return fmt.Errorf("views must specify a query")
		}
		// Validate that columns match the SELECT statement
		if err := validateViewColumns(s); err != nil {
			return fmt.Errorf("column validation failed: %w", err)
		}
	}

	return nil
}

// extractColumnsFromSelect uses TiDB parser to extract column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func extractColumnsFromSelect(query string) ([]string, bool, error) {
	p := parser.New()

	// Remove trailing semicolon if present
	query = strings.TrimSpace(query)
	query = strings.TrimSuffix(query, ";")

	stmtNodes, _, err := p.Parse(query, "", "")
	if err != nil {
		return nil, false, fmt.Errorf("SQL parse error: %w", err)
	}

	if len(stmtNodes) == 0 {
		return nil, false, fmt.Errorf("no SQL statement found")
	}

	columns, hasWildcard := extractFinalColumnNames(stmtNodes[0])
	if len(columns) == 0 {
		return nil, false, fmt.Errorf("no columns found in SELECT statement")
	}

	return columns, hasWildcard, nil
}

// extractFinalColumnNames traverses the AST and returns the final column names
// and whether a wildcard (*) was encountered.
func extractFinalColumnNames(node ast.Node) ([]string, bool) {
	switch x := node.(type) {
	case *ast.SelectStmt:
		return getColumnNamesFromSelect(x)

	case *ast.UnionStmt:
		// Handles UNION / UNION ALL
		// The SQL standard dictates that the column names of a UNION
		// are determined by the first (left-most) SELECT in the chain.
		if x.SelectList != nil && len(x.SelectList.Selects) > 0 {
			return getColumnNamesFromSelect(x.SelectList.Selects[0])
		}
	}

	return []string{}, false
}

// getColumnNamesFromSelect extracts column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func getColumnNamesFromSelect(stmt *ast.SelectStmt) ([]string, bool) {
	var names []string
	hasWildcard := false

	for _, field := range stmt.Fields.Fields {
		// 1. If there is an explicit ALIAS (AS ...), that is the final name.
		if field.AsName.O != "" {
			names = append(names, field.AsName.O)
			continue
		}

		// 2. Handle Wildcards (*)
		if field.WildCard != nil {
			hasWildcard = true
			if field.WildCard.Table.O != "" {
				names = append(names, field.WildCard.Table.O+".*")
			} else {
				names = append(names, "*")
			}
			continue
		}

		// 3. No Alias? Only simple column references are allowed without an alias.
		if colExpr, ok := field.Expr.(*ast.ColumnNameExpr); ok {
			// Case: SELECT t.my_col -> Final name is "my_col"
			names = append(names, colExpr.Name.Name.O)
		} else {
			// Case: Complex expressions (functions, CASE, operators, etc.) require an alias
			var sb strings.Builder
			ctx := format.NewRestoreCtx(format.DefaultRestoreFlags, &sb)
			if err := field.Expr.Restore(ctx); err == nil {
				names = append(names, fmt.Sprintf("ERROR: expression '%s' requires an AS alias", sb.String()))
			} else {
				names = append(names, "ERROR: complex expression requires an AS alias")
			}
		}
	}

	return names, hasWildcard
}
