// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

//go:generate go run . -verbose

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/pingcap/parser"
	"github.com/pingcap/parser/ast"
	"github.com/pingcap/parser/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	// test_driver is required for the parser to work. It registers the AST node constructors
	// via init(). Without it, parser.New() will panic with "no parser driver".
	// See: https://github.com/pingcap/parser/issues/43
	_ "github.com/pingcap/parser/test_driver"

	"gopkg.in/yaml.v3"
)

// spec represents a unified specification for both tables and views
type spec struct {
	Type          string              `yaml:"type"` // "table" or "view"
	Name          string              `yaml:"name"`
	Description   string              `yaml:"description"`
	Platforms     []string            `yaml:"platforms"`
	Columns       []columnSpec        `yaml:"columns"`
	Documentation documentationConfig `yaml:"documentation"`

	// View-specific fields
	Query          string   `yaml:"query,omitempty"`
	RequiredTables []string `yaml:"required_tables,omitempty"`
}

type columnSpec struct {
	Name        string `yaml:"name"`
	Type        string `yaml:"type"`
	Description string `yaml:"description"`
	Format      string `yaml:"format,omitempty"`   // Optional: "unix", "rfc3339"
	Timezone    string `yaml:"timezone,omitempty"` // Optional: "UTC", etc.
	GoType      string `yaml:"go_type,omitempty"`  // Optional: explicit Go type override (e.g., "time.Time")
}

type documentationConfig struct {
	Description   string         `yaml:"description"` // Optional for tables, required for views
	Examples      []exampleQuery `yaml:"examples"`
	Notes         []string       `yaml:"notes"`
	RelatedTables []string       `yaml:"related_tables"` // Optional
}

type exampleQuery struct {
	Title string `yaml:"title"`
	Query string `yaml:"query"`
}

const (
	elasticCopyrightHeader = `// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

`
	codeGeneratedNotice = "// Code generated by gentables. DO NOT EDIT.\n"
)

var (
	specDir  = flag.String("spec-dir", "../../specs", "Directory containing YAML specifications (tables and views)")
	outDir   = flag.String("out-dir", "../../pkg/tables/generated", "Output directory for generated table Go files")
	viewsOut = flag.String("views-out-dir", "../../pkg/views/generated", "Output directory for generated view Go files")
	docsDir  = flag.String("docs-dir", "../../docs/tables", "Output directory for generated table documentation")
	viewsDoc = flag.String("views-docs-dir", "../../docs/views", "Output directory for generated view documentation")
	verbose  = flag.Bool("verbose", false, "Verbose output")
)

func main() {
	flag.Parse()

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Load all YAML spec files
	specs, err := loadSpecs(*specDir)
	if err != nil {
		return fmt.Errorf("failed to load specs: %w", err)
	}

	if *verbose {
		tableCount := 0
		viewCount := 0
		for _, s := range specs {
			switch s.Type {
			case "table":
				tableCount++
			case "view":
				viewCount++
			}
		}
		fmt.Printf("Loaded %d specifications (%d tables, %d views)\n", len(specs), tableCount, viewCount)
	}

	// Create output directories
	if err := os.MkdirAll(*outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	if err := os.MkdirAll(*docsDir, 0755); err != nil {
		return fmt.Errorf("failed to create docs directory: %w", err)
	}
	if err := os.MkdirAll(*viewsOut, 0755); err != nil {
		return fmt.Errorf("failed to create views output directory: %w", err)
	}
	if err := os.MkdirAll(*viewsDoc, 0755); err != nil {
		return fmt.Errorf("failed to create views docs directory: %w", err)
	}

	var tableSpecs, viewSpecs []spec

	// Generate code and documentation for each spec
	for _, s := range specs {
		if *verbose {
			fmt.Printf("Processing %s: %s\n", s.Type, s.Name)
		}

		// Validate the spec based on type
		if err := validateSpec(s); err != nil {
			return fmt.Errorf("%s %s: %w", s.Type, s.Name, err)
		}

		// Route to appropriate generator based on type
		switch s.Type {
		case "table":
			tableSpecs = append(tableSpecs, s)
			// Generate Go code
			if err := generateTableCode(s, *outDir); err != nil {
				return fmt.Errorf("failed to generate code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *docsDir); err != nil {
				return fmt.Errorf("failed to generate docs for %s: %w", s.Name, err)
			}

		case "view":
			viewSpecs = append(viewSpecs, s)
			// Generate Go code
			if err := generateViewCode(s, *viewsOut); err != nil {
				return fmt.Errorf("failed to generate view code for %s: %w", s.Name, err)
			}

			// Generate documentation
			if err := generateDocumentation(s, *viewsDoc); err != nil {
				return fmt.Errorf("failed to generate view docs for %s: %w", s.Name, err)
			}

		default:
			return fmt.Errorf("spec %s has invalid type: %q (must be 'table' or 'view')", s.Name, s.Type)
		}
	}

	// Generate table registry
	if err := writeRegistryFile(tableSpecs, *outDir, "table", "TableSpec", "AllTables", false); err != nil {
		return fmt.Errorf("failed to write table registry: %w", err)
	}

	// Generate view registry
	if err := writeRegistryFile(viewSpecs, *viewsOut, "view", "ViewSpec", "AllViews", true); err != nil {
		return fmt.Errorf("failed to write view registry: %w", err)
	}

	if *verbose {
		fmt.Println("Code generation completed successfully")
		fmt.Println("Formatting generated code...")
	}

	// Format all generated Go files
	if err := formatGeneratedFiles(*outDir, *viewsOut); err != nil {
		return fmt.Errorf("failed to format generated files: %w", err)
	}

	if *verbose {
		fmt.Println("Formatting completed successfully")
	}

	return nil
}

func loadSpecs(dir string) ([]spec, error) {
	pattern := filepath.Join(dir, "*.yaml")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return nil, err
	}

	var specs []spec
	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			return nil, fmt.Errorf("failed to read %s: %w", file, err)
		}

		var s spec
		if err := yaml.Unmarshal(data, &s); err != nil {
			return nil, fmt.Errorf("failed to parse %s: %w", file, err)
		}

		applyDefaults(&s)
		specs = append(specs, s)
	}

	return specs, nil
}

// applyTableDefaults applies sensible defaults to table spec fields
// applyDefaults applies sensible defaults to spec fields
func applyDefaults(s *spec) {
	// Default to all platforms if not specified
	if len(s.Platforms) == 0 {
		s.Platforms = []string{"linux", "darwin", "windows"}
	}

	// Ensure RelatedTables is not nil
	if s.Documentation.RelatedTables == nil {
		s.Documentation.RelatedTables = []string{}
	}
}

func generateTableCode(s spec, outDir string) error {
	var b strings.Builder

	writeGoFileHeader(&b, toPackageName(s.Name), "tables", s.Name, s.Platforms)

	// Check if we need to import time package
	needsTimeImport := false
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		if goType == "time.Time" {
			needsTimeImport = true
			break
		}
	}

	// Generate imports
	b.WriteString("import (\n")
	if needsTimeImport {
		b.WriteString("\t\"time\"\n\n")
	}
	b.WriteString("\t\"github.com/osquery/osquery-go/plugin/table\"\n")
	b.WriteString(")\n\n")

	// Generate result struct
	fmt.Fprintf(&b, "// Result represents a row from the %s table.\n", s.Name)
	b.WriteString("type Result struct {\n")
	
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		fieldName := toGoFieldName(col.Name)
		structTag := buildStructTag(col)
		fmt.Fprintf(&b, "\t%s %s %s // %s\n", fieldName, goType, structTag, col.Description)
	}
	b.WriteString("}\n\n")

	// Generate column function
	fmt.Fprintf(&b, "// Columns returns the column definitions for the %s table.\n", s.Name)
	fmt.Fprintf(&b, "// %s\n", s.Description)
	b.WriteString("func Columns() []table.ColumnDefinition {\n")
	b.WriteString("\treturn []table.ColumnDefinition{\n")

	for _, col := range s.Columns {
		goType := osqueryTypeToGoMethod(col.Type)
		fmt.Fprintf(&b, "\t\ttable.%s(\"%s\"),\n", goType, col.Name)
	}

	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	// Generate table metadata
	fmt.Fprintf(&b, "// TableName is the name of the %s table.\n", s.Name)
	fmt.Fprintf(&b, "const TableName = \"%s\"\n\n", s.Name)

	// Create subdirectory for this table
	tableDir := filepath.Join(outDir, s.Name)
	if err := os.MkdirAll(tableDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", tableDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(tableDir, s.Name+".go")
	return writeFile(filename, b.String())
}

// generateDocumentation generates documentation for both tables and views
func generateDocumentation(s spec, docsDir string) error {
	var b strings.Builder

	writeDocumentationHeader(&b, s.Name, s.Description, s.Platforms)

	// Additional detailed description (required for both tables and views)
	if s.Documentation.Description != "" {
		b.WriteString("## Description\n\n")
		b.WriteString(strings.TrimSpace(s.Documentation.Description) + "\n\n")
	}

	// Schema
	b.WriteString("## Schema\n\n")
	b.WriteString("| Column | Type | Description |\n")
	b.WriteString("|--------|------|-------------|\n")
	for _, col := range s.Columns {
		fmt.Fprintf(&b, "| `%s` | `%s` | %s |\n",
			col.Name, col.Type, col.Description)
	}
	b.WriteString("\n")

	// Required tables (views only)
	if s.Type == "view" && len(s.RequiredTables) > 0 {
		b.WriteString("## Required Tables\n\n")
		b.WriteString("This view requires the following tables to be available:\n\n")
		for _, table := range s.RequiredTables {
			b.WriteString("- `" + table + "`\n")
		}
		b.WriteString("\n")
	}

	// View definition (views only)
	if s.Type == "view" {
		b.WriteString("## View Definition\n\n")
		b.WriteString("```sql\n")
		createViewSQL := fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
		b.WriteString(createViewSQL + "\n")
		b.WriteString("```\n\n")
	}

	writeExamplesSection(&b, s.Documentation.Examples)
	writeNotesSection(&b, s.Documentation.Notes)

	// Related tables
	if len(s.Documentation.RelatedTables) > 0 {
		b.WriteString("## Related Tables\n\n")
		for _, table := range s.Documentation.RelatedTables {
			b.WriteString("- `" + table + "`\n")
		}
		b.WriteString("\n")
	}

	filename := filepath.Join(docsDir, s.Name+".md")
	return writeFile(filename, b.String())
}

// writeRegistryFile writes a single registry file
func writeRegistryFile(specs []spec, outDir, specType, typeName, funcName string, includeRequiredTables bool) error {
	var b strings.Builder

	// Elastic copyright header
	b.WriteString(elasticCopyrightHeader)

	// Code generation notice
	b.WriteString(codeGeneratedNotice)
	b.WriteString("\n")
	b.WriteString("package generated\n\n")

	// Generate imports
	b.WriteString("import (\n")
	if specType == "table" {
		b.WriteString("\t\"github.com/osquery/osquery-go/plugin/table\"\n\n")
	} else {
		b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/hooks\"\n\n")
	}

	// Import all individual packages
	for _, s := range specs {
		pkgName := toPackageName(s.Name)
		if specType == "table" {
			fmt.Fprintf(&b, "\t%s \"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/tables/generated/%s\"\n", pkgName, s.Name)
		} else {
			fmt.Fprintf(&b, "\t%s \"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/views/generated/%s\"\n", pkgName, s.Name)
		}
	}
	b.WriteString(")\n\n")

	// Generate struct
	fmt.Fprintf(&b, "// %s contains metadata and references for a generated %s.\n", typeName, specType)
	fmt.Fprintf(&b, "type %s struct {\n", typeName)
	b.WriteString("\tName        string\n")
	b.WriteString("\tDescription string\n")
	b.WriteString("\tPlatforms   []string\n")

	if specType == "table" {
		b.WriteString("\tTableName string\n")
		b.WriteString("\tColumns   func() []table.ColumnDefinition\n")
	} else {
		b.WriteString("\tRequiredTables []string\n")
		b.WriteString("\tView           func() *hooks.View\n")
	}
	b.WriteString("}\n\n")

	// Generate function
	fmt.Fprintf(&b, "// %s returns metadata and references for all generated %ss.\n", funcName, specType)
	fmt.Fprintf(&b, "func %s() []%s {\n", funcName, typeName)
	fmt.Fprintf(&b, "\treturn []%s{\n", typeName)

	for _, s := range specs {
		pkgName := toPackageName(s.Name)
		b.WriteString("\t\t{\n")
		fmt.Fprintf(&b, "\t\t\tName:        \"%s\",\n", s.Name)
		fmt.Fprintf(&b, "\t\t\tDescription: \"%s\",\n",
			strings.ReplaceAll(s.Description, "\"", "\\\""))
		b.WriteString("\t\t\tPlatforms:   []string{")
		for i, p := range s.Platforms {
			if i > 0 {
				b.WriteString(", ")
			}
			fmt.Fprintf(&b, "\"%s\"", p)
		}
		b.WriteString("},\n")

		if specType == "table" {
			fmt.Fprintf(&b, "\t\t\tTableName: %s.TableName,\n", pkgName)
			fmt.Fprintf(&b, "\t\t\tColumns:   %s.Columns,\n", pkgName)
		} else {
			b.WriteString("\t\t\tRequiredTables: []string{")
			for i, t := range s.RequiredTables {
				if i > 0 {
					b.WriteString(", ")
				}
				fmt.Fprintf(&b, "\"%s\"", t)
			}
			b.WriteString("},\n")
			fmt.Fprintf(&b, "\t\t\tView: %s.View,\n", pkgName)
		}

		b.WriteString("\t\t},\n")
	}

	b.WriteString("\t}\n")
	b.WriteString("}\n")

	filename := filepath.Join(outDir, "registry.go")
	if err := os.WriteFile(filename, []byte(b.String()), 0644); err != nil {
		return err
	}

	return nil
}

func osqueryTypeToGoMethod(osqueryType string) string {
	switch osqueryType {
	case "TEXT":
		return "TextColumn"
	case "INTEGER":
		return "IntegerColumn"
	case "BIGINT":
		return "BigIntColumn"
	case "DOUBLE":
		return "DoubleColumn"
	default:
		return "TextColumn" // Default fallback
	}
}

// osqueryTypeToGoType maps osquery column types to Go types for result structs
func osqueryTypeToGoType(col columnSpec) string {
	// If explicit go_type is specified, use it
	if col.GoType != "" {
		return col.GoType
	}
	
	// Otherwise use default mapping based on osquery type
	switch col.Type {
	case "TEXT":
		return "string"
	case "INTEGER":
		return "int32"
	case "BIGINT":
		return "int64"
	case "DOUBLE":
		return "float64"
	default:
		return "string" // Default fallback
	}
}

// toGoFieldName converts snake_case to CamelCase for Go struct field names
func toGoFieldName(snakeCase string) string {
	return toCamelCase(snakeCase)
}

// buildStructTag builds the osquery struct tag with optional format and timezone
func buildStructTag(col columnSpec) string {
	var parts []string

	// Always include the column name
	parts = append(parts, fmt.Sprintf(`osquery:"%s"`, col.Name))

	// Add format if specified
	if col.Format != "" {
		parts = append(parts, fmt.Sprintf(`format:"%s"`, col.Format))
	}

	// Add timezone if specified
	if col.Timezone != "" {
		parts = append(parts, fmt.Sprintf(`tz:"%s"`, col.Timezone))
	}

	return "`" + strings.Join(parts, " ") + "`"
}

// toPackageName converts a table/view name to an idiomatic Go package name
// (lowercase without underscores)
func toPackageName(name string) string {
	// Remove underscores and convert to lowercase
	return strings.ReplaceAll(strings.ToLower(name), "_", "")
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English).String(parts[i])
	}
	return strings.Join(parts, "")
}

func checkmark(enabled bool) string {
	if enabled {
		return "✅"
	}
	return "❌"
}

func containsAll(slice []string, items []string) bool {
	m := make(map[string]bool)
	for _, s := range slice {
		m[s] = true
	}
	for _, item := range items {
		if !m[item] {
			return false
		}
	}
	return true
}

// writeGoFileHeader writes the common header for generated Go files.
func writeGoFileHeader(b *strings.Builder, packageName, sourceType, name string, platforms []string) {
	b.WriteString(elasticCopyrightHeader)
	b.WriteString(codeGeneratedNotice)
	fmt.Fprintf(b, "// Source: %s/%s.yaml\n\n", sourceType, name)

	// Build tags for platform-specific files
	if len(platforms) > 0 && !containsAll(platforms, []string{"linux", "darwin", "windows"}) {
		b.WriteString("//go:build " + strings.Join(platforms, " || ") + "\n\n")
	}

	fmt.Fprintf(b, "package %s\n\n", packageName)
}

// writeDocumentationHeader writes the common header for documentation files.
func writeDocumentationHeader(b *strings.Builder, name, description string, platforms []string) {
	// Title
	b.WriteString("# " + name + "\n\n")
	b.WriteString(description + "\n\n")

	// Platforms
	b.WriteString("## Platforms\n\n")
	platformMap := map[string]bool{
		"linux":   false,
		"darwin":  false,
		"windows": false,
	}
	for _, p := range platforms {
		platformMap[p] = true
	}
	fmt.Fprintf(b, "- %s Linux\n", checkmark(platformMap["linux"]))
	fmt.Fprintf(b, "- %s macOS\n", checkmark(platformMap["darwin"]))
	fmt.Fprintf(b, "- %s Windows\n\n", checkmark(platformMap["windows"]))
}

// writeExamplesSection writes the examples section for documentation.
func writeExamplesSection(b *strings.Builder, examples []exampleQuery) {
	if len(examples) > 0 {
		b.WriteString("## Examples\n\n")
		for _, example := range examples {
			b.WriteString("### " + example.Title + "\n\n")
			b.WriteString("```sql\n")
			b.WriteString(strings.TrimSpace(example.Query) + "\n")
			b.WriteString("```\n\n")
		}
	}
}

// writeNotesSection writes the notes section for documentation.
func writeNotesSection(b *strings.Builder, notes []string) {
	if len(notes) > 0 {
		b.WriteString("## Notes\n\n")
		for _, note := range notes {
			b.WriteString("- " + note + "\n")
		}
		b.WriteString("\n")
	}
}

// writeFile writes content to a file with standard permissions.
func writeFile(filename string, content string) error {
	return os.WriteFile(filename, []byte(content), 0644)
}

func generateViewCode(s spec, outDir string) error {
	var b strings.Builder

	writeGoFileHeader(&b, toPackageName(s.Name), "views", s.Name, s.Platforms)

	// Check if we need to import time package
	needsTimeImport := false
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		if goType == "time.Time" {
			needsTimeImport = true
			break
		}
	}

	// Generate imports
	b.WriteString("import (\n")
	if needsTimeImport {
		b.WriteString("\t\"time\"\n\n")
	}
	b.WriteString("\t\"github.com/elastic/beats/v7/x-pack/osquerybeat/ext/osquery-extension/pkg/hooks\"\n")
	b.WriteString(")\n\n")

	// Generate result struct
	fmt.Fprintf(&b, "// Result represents a row from the %s view.\n", s.Name)
	b.WriteString("type Result struct {\n")
	for _, col := range s.Columns {
		goType := osqueryTypeToGoType(col)
		fieldName := toGoFieldName(col.Name)
		structTag := buildStructTag(col)
		fmt.Fprintf(&b, "\t%s %s %s // %s\n", fieldName, goType, structTag, col.Description)
	}
	b.WriteString("}\n\n")

	// Generate view function
	fmt.Fprintf(&b, "// View returns the view definition for %s.\n", s.Name)
	fmt.Fprintf(&b, "// %s\n", s.Description)
	b.WriteString("//\n")
	b.WriteString("// Columns:\n")
	for _, col := range s.Columns {
		fmt.Fprintf(&b, "//   - %s (%s): %s\n", col.Name, col.Type, col.Description)
	}
	b.WriteString("func View() *hooks.View {\n")
	b.WriteString("\treturn hooks.NewView(\n")
	fmt.Fprintf(&b, "\t\t\"%s\",\n", s.Name)

	// Required tables
	b.WriteString("\t\t[]string{")
	for i, table := range s.RequiredTables {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(fmt.Sprintf("\"%s\"", table))
	}
	b.WriteString("},\n")

	// Generate the full CREATE VIEW statement from the SELECT query
	// The s.Query contains just the SELECT, we wrap it in CREATE VIEW
	createViewSQL := fmt.Sprintf("CREATE VIEW %s AS\n%s", s.Name, strings.TrimSpace(s.Query))
	b.WriteString("\t\t`" + createViewSQL + "`,\n")
	b.WriteString("\t)\n")
	b.WriteString("}\n")

	// Create subdirectory for this view
	viewDir := filepath.Join(outDir, s.Name)
	if err := os.MkdirAll(viewDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", viewDir, err)
	}

	// Write to file in subdirectory
	filename := filepath.Join(viewDir, s.Name+".go")
	return writeFile(filename, b.String())
}

// formatGeneratedFiles runs goimports and gofmt on all generated Go files.
func formatGeneratedFiles(dirs ...string) error {
	for _, dir := range dirs {
		var files []string

		// Recursively find all .go files
		err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && filepath.Ext(path) == ".go" {
				files = append(files, path)
			}
			return nil
		})
		if err != nil {
			return fmt.Errorf("failed to walk directory %s: %w", dir, err)
		}

		if len(files) == 0 {
			continue
		}

		// Run goimports
		cmd := exec.Command("goimports", append([]string{"-w"}, files...)...)
		if _, err := cmd.CombinedOutput(); err != nil {
			// If goimports is not installed, try using go run
			cmd = exec.Command("go", append([]string{"run", "golang.org/x/tools/cmd/goimports@latest", "-w"}, files...)...)
			if output, err := cmd.CombinedOutput(); err != nil {
				return fmt.Errorf("failed to run goimports on %s: %w\n%s", dir, err, output)
			}
		}

		// Run gofmt
		cmd = exec.Command("gofmt", append([]string{"-w"}, files...)...)
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to run gofmt on %s: %w\n%s", dir, err, output)
		}
	}

	return nil
}

// validateViewColumns validates that the columns specified in the view spec
// match the columns in the SELECT statement.
// It uses TiDB parser to parse the SQL AST and extract column names.
func validateViewColumns(s spec) error {
	// Extract column names from the SELECT statement using SQL parser
	actualColumns, hasSelectStar, err := extractColumnsFromSelect(s.Query)
	if err != nil {
		return fmt.Errorf("failed to parse SELECT statement: %w", err)
	}

	// If query uses SELECT *, skip validation
	if hasSelectStar {
		if *verbose {
			fmt.Printf("Warning: view %s uses SELECT *, skipping column validation\n", s.Name)
		}
		return nil
	}

	// Check if any column has an error (missing alias)
	for _, col := range actualColumns {
		if strings.HasPrefix(col, "ERROR:") {
			return fmt.Errorf(col[7:]) // Remove "ERROR: " prefix
		}
	}

	// Build a map of specified column names
	specifiedColumns := make(map[string]bool)
	for _, col := range s.Columns {
		specifiedColumns[col.Name] = true
	}

	// Build a map of actual column names
	actualColumnMap := make(map[string]bool)
	for _, col := range actualColumns {
		actualColumnMap[col] = true
	}

	// Check if all specified columns exist in the SELECT output
	for _, col := range s.Columns {
		if !actualColumnMap[col.Name] {
			return fmt.Errorf("column %q is specified but not in SELECT output (actual columns: %v)",
				col.Name, actualColumns)
		}
	}

	// Check if all SELECT output columns are specified
	for _, col := range actualColumns {
		if !specifiedColumns[col] {
			return fmt.Errorf("column %q is in SELECT output but not specified in columns list", col)
		}
	}

	return nil
}

// validateDocumentation validates that required documentation fields are present.
func validateDocumentation(doc documentationConfig) error {
	if strings.TrimSpace(doc.Description) == "" {
		return fmt.Errorf("documentation.description is required")
	}
	if len(doc.Examples) == 0 {
		return fmt.Errorf("documentation.examples is required (at least one example must be provided)")
	}
	if len(doc.Notes) == 0 {
		return fmt.Errorf("documentation.notes is required (at least one note must be provided)")
	}
	return nil
}

// validateSpec validates a spec based on its type
func validateSpec(s spec) error {
	// Validate type field
	if s.Type != "table" && s.Type != "view" {
		return fmt.Errorf("type must be 'table' or 'view', got %q", s.Type)
	}

	// Validate columns are specified
	if len(s.Columns) == 0 {
		return fmt.Errorf("must specify at least one column")
	}

	// Validate documentation (same requirements for both tables and views)
	if err := validateDocumentation(s.Documentation); err != nil {
		return err
	}

	// Type-specific validation
	switch s.Type {
	case "table":
		// Tables must not have query field
		if strings.TrimSpace(s.Query) != "" {
			return fmt.Errorf("query field is only valid for views, not tables")
		}

	case "view":
		// Views must have query field
		if strings.TrimSpace(s.Query) == "" {
			return fmt.Errorf("views must specify a query")
		}
		// Validate that columns match the SELECT statement
		if err := validateViewColumns(s); err != nil {
			return fmt.Errorf("column validation failed: %w", err)
		}
	}

	return nil
}

// extractColumnsFromSelect uses TiDB parser to extract column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func extractColumnsFromSelect(query string) ([]string, bool, error) {
	p := parser.New()

	// Remove trailing semicolon if present
	query = strings.TrimSpace(query)
	query = strings.TrimSuffix(query, ";")

	stmtNodes, _, err := p.Parse(query, "", "")
	if err != nil {
		return nil, false, fmt.Errorf("SQL parse error: %w", err)
	}

	if len(stmtNodes) == 0 {
		return nil, false, fmt.Errorf("no SQL statement found")
	}

	columns, hasWildcard := extractFinalColumnNames(stmtNodes[0])
	if len(columns) == 0 {
		return nil, false, fmt.Errorf("no columns found in SELECT statement")
	}

	return columns, hasWildcard, nil
}

// extractFinalColumnNames traverses the AST and returns the final column names
// and whether a wildcard (*) was encountered.
func extractFinalColumnNames(node ast.Node) ([]string, bool) {
	switch x := node.(type) {
	case *ast.SelectStmt:
		return getColumnNamesFromSelect(x)

	case *ast.UnionStmt:
		// Handles UNION / UNION ALL
		// The SQL standard dictates that the column names of a UNION
		// are determined by the first (left-most) SELECT in the chain.
		if x.SelectList != nil && len(x.SelectList.Selects) > 0 {
			return getColumnNamesFromSelect(x.SelectList.Selects[0])
		}
	}

	return []string{}, false
}

// getColumnNamesFromSelect extracts column names from a SELECT statement.
// Returns the column names and whether SELECT * was used.
func getColumnNamesFromSelect(stmt *ast.SelectStmt) ([]string, bool) {
	var names []string
	hasWildcard := false

	for _, field := range stmt.Fields.Fields {
		// 1. If there is an explicit ALIAS (AS ...), that is the final name.
		if field.AsName.O != "" {
			names = append(names, field.AsName.O)
			continue
		}

		// 2. Handle Wildcards (*)
		if field.WildCard != nil {
			hasWildcard = true
			if field.WildCard.Table.O != "" {
				names = append(names, field.WildCard.Table.O+".*")
			} else {
				names = append(names, "*")
			}
			continue
		}

		// 3. No Alias? Only simple column references are allowed without an alias.
		if colExpr, ok := field.Expr.(*ast.ColumnNameExpr); ok {
			// Case: SELECT t.my_col -> Final name is "my_col"
			names = append(names, colExpr.Name.Name.O)
		} else {
			// Case: Complex expressions (functions, CASE, operators, etc.) require an alias
			var sb strings.Builder
			ctx := format.NewRestoreCtx(format.DefaultRestoreFlags, &sb)
			if err := field.Expr.Restore(ctx); err == nil {
				names = append(names, fmt.Sprintf("ERROR: expression '%s' requires an AS alias", sb.String()))
			} else {
				names = append(names, "ERROR: complex expression requires an AS alias")
			}
		}
	}

	return names, hasWildcard
}
