// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

// +build linux,386 linux,amd64

package socket

import (
	"fmt"
	"strconv"
	"sync/atomic"
	"time"

	"github.com/pkg/errors"
	"golang.org/x/sys/unix"

	"github.com/elastic/beats/libbeat/common"
	"github.com/elastic/beats/libbeat/common/cfgwarn"
	"github.com/elastic/beats/libbeat/logp"
	"github.com/elastic/beats/metricbeat/mb"
	"github.com/elastic/beats/x-pack/auditbeat/module/system"
	"github.com/elastic/beats/x-pack/auditbeat/module/system/socket/guess"
	"github.com/elastic/beats/x-pack/auditbeat/module/system/socket/helper"
	"github.com/elastic/beats/x-pack/auditbeat/tracing"
	"github.com/elastic/go-perf"
	"github.com/elastic/go-sysinfo"
	"github.com/elastic/go-sysinfo/providers/linux"
)

const (
	moduleName     = "system"
	metricsetName  = "socket"
	fullName       = moduleName + "/" + metricsetName
	namespace      = "system.audit.socket"
	detailSelector = metricsetName + "detailed"
	auditbeatGroup = "auditbeat"
	// Magic value to detect clock-sync events generated by the metricset.
	clockSyncMagic uint64 = 0x42DEADBEEFABCDEF
)

var (
	kernelVersion string
	eventCount    uint64
)

// MetricSet for system/socket.
type MetricSet struct {
	system.SystemMetricSet
	templateVars common.MapStr
	config       Config
	log          *logp.Logger
	detailLog    *logp.Logger
	installer    helper.ProbeInstaller
	perfChannel  *tracing.PerfChannel
	isDebug      bool
	isDetailed   bool
}

func init() {
	mb.Registry.MustAddMetricSet(moduleName, metricsetName, New,
		mb.DefaultMetricSet(),
		mb.WithNamespace(namespace),
	)
	var err error
	if kernelVersion, err = linux.KernelVersion(); err != nil {
		logp.Err("Failed fetching Linux kernel version: %v", err)
	}
}

// New constructs a new MetricSet.
func New(base mb.BaseMetricSet) (mb.MetricSet, error) {
	cfgwarn.Beta("The %s dataset is beta.", fullName)

	config := defaultConfig
	if err := base.Module().UnpackConfig(&config); err != nil {
		return nil, errors.Wrapf(err, "failed to unpack the %s config", fullName)
	}

	ms := &MetricSet{
		SystemMetricSet: system.NewSystemMetricSet(base),
		templateVars:    make(common.MapStr),
		config:          config,
		log:             logp.NewLogger(metricsetName),
		isDebug:         logp.IsDebug(metricsetName),
		detailLog:       logp.NewLogger(detailSelector),
		isDetailed:      logp.IsDebug(detailSelector),
	}

	// Setup the metricset before Run() so that startup can be halted in case of
	// error.
	if err := ms.Setup(); err != nil {
		return nil, errors.Wrapf(err, "%s dataset setup failed", fullName)
	}
	return ms, nil
}

// Run the metricset. This will loop until the passed reporter is cancelled.
func (m *MetricSet) Run(r mb.PushReporterV2) {
	defer m.log.Infof("%s terminated.", fullName)
	defer m.Cleanup()

	if err := m.perfChannel.Run(); err != nil {
		err = errors.Wrap(err, "unable to start perf channel")
		r.Error(err)
		m.log.Error(err)
		return
	}
	// Launch the clock-synchronization ticker.
	go m.clockSyncLoop(m.config.ClockSyncPeriod, r.Done())
	st := NewState(r,
		m.log,
		m.config.FlowInactiveTimeout,
		m.config.FlowTerminationTimeout,
		m.config.ClockMaxDrift)

	if procs, err := sysinfo.Processes(); err != nil {
		m.log.Error("Failed to bootstrap process table using /proc", err)
	} else {
		for _, p := range procs {
			if i, err := p.Info(); err == nil {
				process := process{
					name:        i.Name,
					pid:         uint32(i.PID),
					args:        i.Args,
					createdTime: i.StartTime,
					path:        i.Exe,
				}

				if user, err := p.User(); err == nil {
					toUint32 := func(id string) uint32 {
						num, _ := strconv.Atoi(id)
						return uint32(num)
					}
					process.uid = toUint32(user.UID)
					process.euid = toUint32(user.EUID)
					process.gid = toUint32(user.GID)
					process.egid = toUint32(user.EGID)
					process.hasCreds = true
				}

				st.CreateProcess(process)
			}
		}
		m.log.Info("Bootstrapped process table using /proc")
	}

	// Dispatch loop.
	for running := true; running; {
		select {
		case <-r.Done():
			running = false

		case iface, ok := <-m.perfChannel.C():
			if !ok {
				running = false
				break
			}
			v, ok := iface.(event)
			if !ok {
				m.log.Errorf("Received an event of wrong type: %T", iface)
				continue
			}
			if m.isDetailed {
				m.detailLog.Debug(v.String())
			}
			if err := v.Update(st); err != nil {
				m.log.Infof("error processing event '%s': %v", v.String(), err)
			}
			atomic.AddUint64(&eventCount, 1)

		case err := <-m.perfChannel.ErrC():
			m.log.Errorf("Error received from perf channel: %v", err)
			running = false

		case numLost := <-m.perfChannel.LostC():
			if numLost != ^uint64(0) {
				m.log.Warnf("Lost %d events", numLost)
			} else {
				m.log.Warn("Lost the whole ringbuffer")
			}
		}
	}
}

// Setup performs all the initialisations required for KProbes monitoring.
func (m *MetricSet) Setup() (err error) {
	m.log.Infof("Setting up %s for kernel %s", fullName, kernelVersion)

	//
	// Validate that tracefs / debugfs is present and kprobes are available
	//
	var traceFS *tracing.TraceFS
	if m.config.TraceFSPath == nil {
		traceFS, err = tracing.NewTraceFS()
	} else {
		traceFS, err = tracing.NewTraceFSWithPath(*m.config.TraceFSPath)
	}
	if err != nil {
		return errors.Wrap(err, "tracefs/debugfs is not mounted or not writeable")
	}

	//
	// Setup initial template variables
	//
	m.templateVars.Update(baseTemplateVars)
	m.templateVars.Update(archVariables)

	//
	// Create probe installer
	//
	extra := WithNoOp()
	if m.config.DevelopmentMode {
		extra = WithFilterPort(22)
	}
	m.installer = newProbeInstaller(traceFS,
		WithGroup(auditbeatGroup),
		WithTemplates(m.templateVars),
		extra)
	defer func() {
		if err != nil {
			m.installer.UninstallInstalled()
		}
	}()

	//
	// remove existing KProbes from Auditbeat
	//
	if err = m.installer.UninstallIf(isOwnProbe); err != nil {
		return errors.Wrap(err, "unable to delete existing KProbes. Is Auditbeat already running?")
	}

	//
	// Load available kernel functions for tracing
	//
	functions, err := LoadTracingFunctions(traceFS)
	if err != nil {
		return errors.Wrap(err, "cannot load available_filter_functions. Check the mount point for your tracefs/debugfs and permissions")
	}

	//
	// Resolve function names from alternatives
	//
	for varName, alternatives := range functionAlternatives {
		if exists, _ := m.templateVars.HasKey(varName); exists {
			return fmt.Errorf("variable %s overwrites existing key", varName)
		}
		selected, found := functions.FirstOf(alternatives)
		if !found {
			return fmt.Errorf("none of the required functions for %s is found. One of %v is required", varName, alternatives)
		}
		if m.isDebug {
			m.log.Debugf("Selected kernel function %s for %s", selected, varName)
		}
		m.templateVars[varName] = selected
	}

	//
	// Make sure all the required kernel functions are available
	//
	for _, probeDef := range installKProbes {
		probeDef = probeDef.ApplyTemplate(m.templateVars)
		if !functions.Contains(probeDef.Probe.Address) {
			return fmt.Errorf("required function '%s' is not available for tracing in the current kernel (%s)", probeDef.Probe.Address, kernelVersion)
		}
	}

	//
	// Guess all the required parameters
	//
	if err = guess.GuessAll(m.installer,
		guess.Context{
			Log:     m.log,
			Vars:    m.templateVars,
			Timeout: m.config.GuessTimeout,
		}); err != nil {
		return errors.Wrap(err, "unable to guess one or more required parameters")
	}

	if m.isDetailed {
		m.log.Debugf("%d template variables in use:", len(m.templateVars))
		for key, value := range m.templateVars {
			m.detailLog.Debugf("  %s = %v", key, value)
		}
	}

	//
	// Create perf channel
	//
	m.perfChannel, err = tracing.NewPerfChannel(
		tracing.WithBufferSize(m.config.PerfQueueSize),
		tracing.WithErrBufferSize(m.config.ErrQueueSize),
		tracing.WithLostBufferSize(m.config.LostQueueSize),
		tracing.WithRingSizeExponent(m.config.RingSizeExp),
		tracing.WithTID(perf.AllThreads),
		tracing.WithTimestamp())
	if err != nil {
		return errors.Wrapf(err, "unable to create perf channel")
	}

	//
	// Register Kprobes
	//
	for _, probeDef := range installKProbes {
		format, decoder, err := m.installer.Install(probeDef)
		if err != nil {
			return errors.Wrapf(err, "unable to register probe %s", probeDef.Probe.String())
		}
		if err = m.perfChannel.MonitorProbe(format, decoder); err != nil {
			return errors.Wrapf(err, "unable to monitor probe %s", probeDef.Probe.String())
		}
	}
	return nil
}

// Cleanup must be called so that kprobes are not left around after exit.
func (m *MetricSet) Cleanup() {
	if m.perfChannel != nil {
		if err := m.perfChannel.Close(); err != nil {
			m.log.Warnf("Failed to close perf channel on exit: %v", err)
		}
	}
	if m.installer != nil {
		if err := m.installer.UninstallIf(isOwnProbe); err != nil {
			m.log.Warnf("Failed to remove KProbes on exit: %v", err)
		}
	}
}

func (m *MetricSet) clockSyncLoop(interval time.Duration, done <-chan struct{}) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()
	triggerClockSync()
	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			triggerClockSync()
		}
	}
}

func triggerClockSync() {
	// This generates a uname (SYS_UNAME) syscall event that contains
	// clockSyncMagic at the first 8 bytes of the passed buffer and
	// the current UNIX nano timestamp at the following 8 bytes.
	//
	// The magic bytes are used to filter-out legitimate uname() calls
	// from this process and the timestamp is used as a reference point for
	// synchronization with the internal clock that the kernel uses for stamping
	// the tracing events it produces.
	var buf unix.Utsname
	tracing.MachineEndian.PutUint64(buf.Sysname[:], clockSyncMagic)
	tracing.MachineEndian.PutUint64(buf.Sysname[8:], uint64(time.Now().UnixNano()))
	unix.Uname(&buf)
}

func isOwnProbe(probe tracing.Probe) bool {
	return probe.Group == auditbeatGroup
}
