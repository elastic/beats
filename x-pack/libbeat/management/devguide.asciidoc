# Writing V2 support for a beat

## What is this document?

This guide is meant to be a high-level guide for adapting an individual beat to the newer V2 control protocol used by elastic-agent; 
this includes component registration, config transformation, and tests.


## Introduction: The V2 controller

The V2 remote management protocol is fundamentally different from V1; whereas V1 required the registration of a number of callbacks from a client to a server, 
such as `OnConfig()` and `OnStop()`, V2, is more parallelized and flexible, 
but as a trade-off requires more work on behalf of a client to manage the flow of commands from the server. 

From the perspective of an individual beat however, little has changed, as this newer V2 server will still look for a `ReloadableList` callback registered by an
individual beat. However, the V2 server also offloads the work of transforming the "agent-native" config generated by fleet onto clients. 
Previously, this config transformation was performed by an AST layer in elastic-agent, 
as configured by YML spec files that lived in `elastic-agent/internal/spec`. In V2, this transformation must be performed by an individual beat.


## Component Registration

There are two components, one of which is optional, that must be registered with the management controller for a beat to run under the V2 controller:

### The Reloader

The reloader component is not unique to V2, and remains largely unchanged from it's V1 state. Currently, all beats have a line like this (the following example is from metricbeat), in their early startup state:

```
reload.RegisterV2.MustRegisterInput(modules)
```

The `MustRegisterInput` method takes a single argument: component that satisfies a `ReloadableList` interface.
For most beats, this component will be a wrapper around an array of individual modules/inputs that maps to each individual input in the upstream fleet config.
In this example agent YAML config, each item under the `streams` key will become an individual input config in the array sent to the `ReloadableList` interface:
```
  - id: logfile-system-default-system
    name: system-1
    revision: 1
    type: logfile
    use_output: default
    meta:
      package:
        name: system
        version: 1.17.0
    data_stream:
      namespace: default
    streams:
      - id: logfile-system.auth-default-system
        [...]
      - id: logfile-system.syslog-default-system
        [...]
```

### Config Transformation

Unlike with the V1 agent controller, with the V2 controller, individual beats will be required to make any transformations needed to format their config.
In V1, config transformation was performed by the agent and configured by a YAML file. In V2, this transformation process is fundamentally different, 
as beats no longer receive the entire agent config, but individual per-input configs, 
and so the logic of the AST transformations present in `elastic-agent/internal/spec` cannot be moved one-to-one over to the V2 client in beats.

In order for a beat to perform its own config transformations, it must register a callback function, as such:
```
import "github.com/elastic/beats/v7/x-pack/libbeat/management"
...
management.ConfigTransform.SetTransform(metricbeatCfg)
```

The `SetTransform` method takes a function with the following signature: 
```
func(rawIn *proto.UnitExpectedConfig, agentInfo *client.AgentInfo) ([]*reload.ConfigWithMeta, error)
```

This registration will usually happen early in the startup process, and for licensing reasons, must happen in `x-pack` code. 
For the sake of consistency, both filebeat and metricbeat register this callback in `x-pack/[beatname]/cmd`. If a beat does not register a callback,
the V2 client will perform a basic config transformation that adds metadata `processor` fields and breaks apart the individual inputs under the `streams` key.

This function callback takes an `AgentInfo` struct that can be used for creating metadata `add_field` processors, as well as a `UnitExpectedConfig` structure that
represents the individual input config demonstrated in the previous section. The return value, `[]*reload.ConfigWithMeta`, should represent the final config that 
will be passed to the reloader interface.

The V2 client library provides a number of convenience functions. `CreateInputsFromStreams` will generate an array of input configs from the `streams` value, 
complete with metadata fields. `CreateReloadConfigFromInputs` will turn a list of input configs in the form of `[]map[string]interface{}` into a list of reloader
configs that can be returned and sent to the registered reloader.


## Tests

The V2 client controller contains a test suite under `x-pack/libbeat/management/tests`. These tests are broken down to one beat per folder,
as the tests themselves will try to initialize a number of global variables, requiring the CI process to break them apart to individual executables.
To add a new beat to the test, you must fetch the `BeatsRootCmd` object that starts a beat executible, and pass it to a wrapper that will
modify the beats environment for use in a test wrapper:
```
import fbroot "github.com/elastic/beats/v7/x-pack/filebeat/cmd"
...
filebeatCmd := fbroot.Filebeat()
tests.InitBeatsForTest(t, filebeatCmd)
```

The test suite uses a mock `elastic-agent` server, requiring only a `UnitExpectedConfig{}` with the beat's desired config. After the mock server has been configured,
the `BeatsRootCmd` object can be started as it would in any normal non-test setup:
```
    // Setup the mock server, return the tmpfile where the beat will output metrics, and the server handler
	outPath, server := tests.SetupTestEnv(t, expectedBeatsConfig, serverRuntimeInSeconds)
	defer server.Srv.Stop()

	// start the beat. This is a blocking command, and beats will shut down after `serverRuntimeInSeconds`.
	err := filebeatCmd.Execute()
	require.NoError(t, err)

	// Read the reported metrics send to the `file` output by the beat
	events := tests.ReadEvents(t, outPath)
	t.Logf("Got %d events", len(events))
```

For more in-depth examples, examine the `fbtest` and `mbtest` directories.