// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//go:build linux

package kprobes

import (
	"sync"

	"github.com/elastic/beats/v7/auditbeat/tracing"
)

var probeEventPool = sync.Pool{
	New: func() interface{} {
		return &ProbeEvent{}
	},
}

// ProbeEvent represents a kprobe event.
// Different Mask* fields represent different kind of events.
// For MaskMonitor, the fields that are filled are:
//
//	ParentIno, ParentDevMajor, ParentDevMinor, FileIno, FileDevMajor, FileDevMinor, FileName
//
// For MaskCreate, the fields that are filled are:
//
//	ParentIno, ParentDevMajor, ParentDevMinor, FileIno, FileDevMajor, FileDevMinor, FileName
//
// For MaskDelete, the fields that are filled are:
//
//	ParentIno, ParentDevMajor, ParentDevMinor, FileName
//
// For MaskModify, the fields that are filled are:
//
//	FileIno, FileDevMajor, FileDevMinor
//
// For MaskAttrib, the fields that are filled are:
//
//	FileIno, FileDevMajor, FileDevMinor
//
// For MaskMoveTo, the fields that are filled are:
//
//	ParentIno, ParentDevMajor, ParentDevMinor, FileName
//
// For MaskMoveFrom, the fields that are filled are:
//
//	ParentIno, ParentDevMajor, ParentDevMinor, FileName
//
// The reason that we opted for one Type (aka ProbeEvent struct) to capture different events as
// inner fields is to utilise the same sync.Pool. As events are eventually generated by any
// process on the system, a storm of events can easily occur, avoiding constant allocations
// should benefit the performance of garbage collector.
type ProbeEvent struct {
	Meta           tracing.Metadata `kprobe:"metadata"`
	MaskMonitor    uint32
	MaskCreate     uint32 `kprobe:"mc,allowundefined"`
	MaskDelete     uint32 `kprobe:"md,allowundefined"`
	MaskAttrib     uint32 `kprobe:"ma,allowundefined"`
	MaskModify     uint32 `kprobe:"mm,allowundefined"`
	MaskDir        uint32 `kprobe:"mid,allowundefined"`
	MaskMoveTo     uint32 `kprobe:"mmt,allowundefined"`
	MaskMoveFrom   uint32 `kprobe:"mmf,allowundefined"`
	ParentIno      uint64 `kprobe:"pi"`
	ParentDevMajor uint32 `kprobe:"pdmj"`
	ParentDevMinor uint32 `kprobe:"pdmn"`
	FileIno        uint64 `kprobe:"fi"`
	FileDevMajor   uint32 `kprobe:"fdmj"`
	FileDevMinor   uint32 `kprobe:"fdmn"`
	FileName       string `kprobe:"fn"`
}

// allocProbeEvent gets a ProbeEvent from the sync.Pool and zero it out. Note that depending on the
// pool state an allocation might happen.
func allocProbeEvent() any {
	probeEvent := probeEventPool.Get().(*ProbeEvent)
	// zero out all Mask related fields
	probeEvent.MaskMonitor = 0
	probeEvent.MaskCreate = 0
	probeEvent.MaskDelete = 0
	probeEvent.MaskAttrib = 0
	probeEvent.MaskModify = 0
	probeEvent.MaskDir = 0
	probeEvent.MaskMoveTo = 0
	probeEvent.MaskMoveFrom = 0
	return probeEvent
}

// allocDeleteProbeEvent gets a ProbeEvent from the sync.Pool and zero it out except for MaskDelete.
// Note that depending on the pool state an allocation might happen.
func allocDeleteProbeEvent() any {
	probeEvent := probeEventPool.Get().(*ProbeEvent)
	// zero out all Mask related fields except MaskDelete
	probeEvent.MaskMonitor = 0
	probeEvent.MaskCreate = 0
	probeEvent.MaskDelete = 1
	probeEvent.MaskAttrib = 0
	probeEvent.MaskModify = 0
	probeEvent.MaskDir = 0
	probeEvent.MaskMoveTo = 0
	probeEvent.MaskMoveFrom = 0
	return probeEvent
}

// allocMonitorProbeEvent gets a ProbeEvent from the sync.Pool and zero it out except for MaskMonitor.
// Note that depending on the pool state an allocation might happen.
func allocMonitorProbeEvent() any {
	probeEvent := probeEventPool.Get().(*ProbeEvent)
	// zero out all Mask related fields except MaskMonitor
	probeEvent.MaskMonitor = 1
	probeEvent.MaskCreate = 0
	probeEvent.MaskDelete = 0
	probeEvent.MaskAttrib = 0
	probeEvent.MaskModify = 0
	probeEvent.MaskDir = 0
	probeEvent.MaskMoveTo = 0
	probeEvent.MaskMoveFrom = 0
	return probeEvent
}

// releaseProbeEvent returns a ProbeEvent to the pool.
func releaseProbeEvent(c *ProbeEvent) {
	if c == nil {
		return
	}

	probeEventPool.Put(c)
}
