// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

//go:build linux

package kprobes

import (
	"errors"
	"path/filepath"

	"golang.org/x/sys/unix"
)

type Emitter interface {
	Emit(ePath string, pid uint32, op uint32) error
}

type eProcessor struct {
	paths       pathTraverser
	emitter     Emitter
	cache       *dEntryCache
	isRecursive bool
}

func newEventProcessor(p pathTraverser, e Emitter, isRecursive bool) *eProcessor {
	return &eProcessor{
		paths:       p,
		emitter:     e,
		cache:       newDirEntryCache(),
		isRecursive: isRecursive,
	}
}

// process handles a given probe event and correlates it with other events, then sends
// an event for the upstream Emitter if the event is valid. For example, a modify event will be ignored if
// we have no existing cache entry for that file.
func (e *eProcessor) process(pe *ProbeEvent) error {
	// after processing return the probe event to the pool
	defer releaseProbeEvent(pe)

	switch {
	case pe.MaskMonitor == 1:
		// Monitor events are only generated by our own pathTraverser.AddPathToMonitor or
		// pathTraverser.WalkAsync

		monitorPath, match := e.paths.GetMonitorPath(pe.FileIno, pe.FileDevMajor, pe.FileDevMinor, pe.FileName)
		if !match {
			return nil
		}

		entry := e.cache.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		parentEntry := e.cache.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil {
			entry = &dEntry{
				Name:     monitorPath.fullPath,
				Ino:      pe.FileIno,
				Depth:    monitorPath.depth,
				DevMajor: pe.FileDevMajor,
				DevMinor: pe.FileDevMinor,
			}
		} else {
			if entry == nil {
				entry = &dEntry{
					Name:     pe.FileName,
					Ino:      pe.FileIno,
					Depth:    parentEntry.Depth + 1,
					DevMajor: pe.FileDevMajor,
					DevMinor: pe.FileDevMinor,
				}
			}
		}

		e.cache.Add(entry, parentEntry)

		if !monitorPath.isFromMove {
			return nil
		}

		return e.emitter.Emit(entry.Path(), monitorPath.tid, unix.IN_MOVED_TO)

	case pe.MaskCreate == 1:
		parentEntry := e.cache.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil || parentEntry.Depth >= 1 && !e.isRecursive {
			return nil
		}

		entry := &dEntry{
			Children: nil,
			Name:     pe.FileName,
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		}

		e.cache.Add(entry, parentEntry)

		return e.emitter.Emit(entry.Path(), pe.Meta.TID, unix.IN_CREATE)

	case pe.MaskModify == 1:
		entry := e.cache.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		if entry == nil {
			return nil
		}

		return e.emitter.Emit(entry.Path(), pe.Meta.TID, unix.IN_MODIFY)

	case pe.MaskAttrib == 1:
		entry := e.cache.Get(dKey{
			Ino:      pe.FileIno,
			DevMajor: pe.FileDevMajor,
			DevMinor: pe.FileDevMinor,
		})

		if entry == nil {
			return nil
		}

		return e.emitter.Emit(entry.Path(), pe.Meta.TID, unix.IN_ATTRIB)

	case pe.MaskMoveFrom == 1:
		parentEntry := e.cache.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil || parentEntry.Depth >= 1 && !e.isRecursive {
			e.cache.MoveClear(uint64(pe.Meta.TID))
			return nil
		}

		entry := parentEntry.GetChild(pe.FileName)
		if entry == nil {
			return nil
		}

		entryPath := entry.Path()

		e.cache.MoveFrom(uint64(pe.Meta.TID), entry)

		return e.emitter.Emit(entryPath, pe.Meta.TID, unix.IN_MOVED_FROM)

	case pe.MaskMoveTo == 1:
		parentEntry := e.cache.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil || parentEntry.Depth >= 1 && !e.isRecursive {
			// if parentEntry is nil then this move event is not
			// for a directory we monitor
			e.cache.MoveClear(uint64(pe.Meta.TID))
			return nil
		}

		if existingChild := parentEntry.GetChild(pe.FileName); existingChild != nil {
			e.cache.Remove(existingChild)
			existingChild.Release()
		}

		moved, err := e.cache.MoveTo(uint64(pe.Meta.TID), parentEntry, pe.FileName, func(path string) error {
			return e.emitter.Emit(path, pe.Meta.TID, unix.IN_MOVED_TO)
		})
		if err != nil {
			return err
		}
		if moved {
			return nil
		}

		newEntryPath := filepath.Join(parentEntry.Path(), pe.FileName)
		e.paths.WalkAsync(newEntryPath, parentEntry.Depth+1, pe.Meta.TID)

		return nil

	case pe.MaskDelete == 1:
		parentEntry := e.cache.Get(dKey{
			Ino:      pe.ParentIno,
			DevMajor: pe.ParentDevMajor,
			DevMinor: pe.ParentDevMinor,
		})

		if parentEntry == nil || parentEntry.Depth >= 1 && !e.isRecursive {
			return nil
		}

		entry := parentEntry.GetChild(pe.FileName)
		if entry == nil {
			return nil
		}

		entryPath := entry.Path()

		e.cache.Remove(entry)

		if err := e.emitter.Emit(entryPath, pe.Meta.TID, unix.IN_DELETE); err != nil {
			return err
		}

		entry.Release()

		return nil
	default:
		return errors.New("unknown event type")
	}
}
