= Developer guide: creating a new Beat

This guide walks you through the steps for creating a new Elastic Beat.
The Beats are a collection of lightweight daemons that collection
operational data from your servers and ship it to Logstash or Elasticsearch.
The common parts from all Beats are placed in the libbeat library, which
contains packages for sending data to Elasticsearch and Logstash, for
configuration file handling, for signal handling, for logging and so on. By
using this common framework, we can ensure that all Beats are behaving the same
and they are easy to package and run with common tools.

== Getting ready

Libbeat and all Beats are written in http://golang.org/[Go], so having it
installed and knowing its basics is a prerequisite for understanding this guide.
However, don't worry if you are not yet a Go expert, it is a sufficiently new
language that very few people can consider themselves experts.  In fact, several
people learned Go by contributing to Packetbeat & libbeat, including the
original Packetbeat authors.

To exemplify this guide with a working example, we will follow
https://github.com/elastic/topbeat[Topbeat] source code. Topbeat is similar to
the `top` command line tool but instead of printing the statistics to the screen
it ships them to Elasticsearch for storage.

After having https://golang.org/doc/install[installed Go] and having setup the
https://golang.org/doc/code.html#GOPATH[GOPATH] environment variable to point to
your preferred workspace location, a simple way of getting the source code for
topbeat and libeat and compiling them at the same time is to do:

[source,shell]
----------------------------------------------------------------------
go get github.com/elastic/topbeat
----------------------------------------------------------------------

== Overview

At the high level, a simple Beat like Topbeat has two main components: one that
collects the actual data and the Publisher. They communicate via a Go channel,
over which *events* are sent. The Publisher is implemented in libbeat, so you
typically only have to worry about the logic specific to your Beat. Besides the
Publisher, libbeat offers common services like configuration management,
logging, daemonizing/windows service handling and in the future it will offer
data processing modules like filtering or sampling.

image:./images/beat_overview.png[Beat overview architecture]

An event is JSON like object (Golang type `map[string]interface{}`) that
contains the collected data and which is indexed into Elasticsearch. The only
rules are that it must contain a `timestamp` field and a `type` field. Beyond
that, it doesn't matter what these events contain or how often they are created.
Here is an example Topbeat event:

[source,json]
----------------------------------------------------------------------
{
  count":1,
  "proc.cpu":{
    "user":20,
    "percent":0.983284169124877,
    "system":0,
    "total":20,
    "start_time":"20:20"
  },
  "proc.mem":{
    "size":333772,
    "rss":6316,
    "share":2996
  },
  "proc.name":"topbeat",
  "proc.pid":13954,
  "proc.ppid":10027,
  "proc.state":"sleeping",
  "shipper":"vagrant-ubuntu-trusty-64",
  "timestamp":"2015-08-06T20:20:34.089Z",
  "type":"proc"
}
----------------------------------------------------------------------

Now that you have the big picture, lets dig into the code.

== Beat specific code

The Beat specific code should implement the `Beater` interface which is found in
libbeat. This means your Beat should implement 5 methods:

[source,go]
----------------------------------------------------------------------
type Beater interface {
	Config(*Beat) error
	Setup(*Beat) error
	Run(*Beat) error
	Cleanup(*Beat) error
	Stop()
}
----------------------------------------------------------------------

The `Beat` parameter received by most of these methods contains data about the
Beat, things like the name, version and common configuration options.

Let's go through each of these methods and look at a sample implementation.


== Configuration

The `Config` method deals with the configuration file and optionally with
custom CLI flags.

The recommended way of handling the configuration is to create a
`ConfigSettings` type that matches the structure of the expected configuration
file. Here is an example configuration section for Topbeat:

[source,yaml]
----------------------------------------------------------------------
input:
  period: 1

  procs: [".*"]
----------------------------------------------------------------------

And here are the corresponding Go structures:

[source,go]
----------------------------------------------------------------------
type TopConfig struct {
	Period *int64
	Procs  *[]string
}

type ConfigSettings struct {
	Input TopConfig
}
----------------------------------------------------------------------

Pointers are used to separate between the case when the setting is completely
missing from the configuration file and when it has a values that matches the
type default.

With these structures defined, the `Config` function looks like this:


[source,go]
----------------------------------------------------------------------
func (tb *Topbeat) Config(b *beat.Beat) error {

	err := cfgfile.Read(&tb.TbConfig) <1>
	if err != nil {
		logp.Err("Error reading configuration file: %v", err)
		return err
	}

	if tb.TbConfig.Input.Period != nil { <2>
		tb.period = time.Duration(*tb.TbConfig.Input.Period) * time.Second
	} else {
		tb.period = 1 * time.Second
	}

	[...]

	return nil
}
----------------------------------------------------------------------

<1> Read the configuration.
<2> Set default values for options that are not present in the configuration
    file.

=== Setup

The `Setup` method gives you the opportunity to execute things before the main
loop, usually for initialization. In the case of Topbeat, it only links the
`events` channel with the publisher queue. This is the event channel mentioned
in the Overview section.

[source,go]
----------------------------------------------------------------------
func (tb *Topbeat) Setup(b *beat.Beat) error {

	tb.events = publisher.Publisher.Queue
	return nil
}
----------------------------------------------------------------------

=== Run

The `Run` method should contain your main application loop. For Topbeat it looks
like this:

[source,go]
----------------------------------------------------------------------
func (t *Topbeat) Run(b *beat.Beat) error {

	t.isAlive = true

	t.initProcStats()

	var err error

	for t.isAlive {
		time.Sleep(t.period)

		err = t.exportSystemStats()
		if err != nil {
			logp.Err("Error reading system stats: %v", err)
		}
		[...]
	}

	return err
}
----------------------------------------------------------------------

Inside the loop, Topbeat sleeps for a configured period of time and then
captures the required data and sends it to the publisher via the `events`
channel.

The actual sending is done inside the `exportSystemStats()` function, here is an
example code snippet:

[source,go]
----------------------------------------------------------------------
  event := common.MapStr{
      "timestamp": common.Time(time.Now()), <1>
      "type":      "system",
      "load":      load_stat,
      "cpu":       cpu_stat,
      "mem":       mem_stat,
      "swap":      swap_stat,
  }

  t.events <- event
----------------------------------------------------------------------

<1> The `timestamp` fields needs to be of time `common.Time`.

=== Cleanup

The `Cleanup` method is executed after the main loop finishes or is interrupted
and gives you the opportunity to release any resources you might use. For
Topbeat, it's completely empty:

[source,go]
----------------------------------------------------------------------
func (tb *Topbeat) Cleanup(b *beat.Beat) error {
	return nil
}
----------------------------------------------------------------------

=== Stop

Finally, the `Stop` method is called when the Beat is signalled to stop, for
example via the SIGTERM signal on Unix systems or via the service control
interface on Windows. In the case of Topbeat, it simply sets `isAlive` to
`false` which breaks the main loop.

[source,go]
----------------------------------------------------------------------
func (t *Topbeat) Stop() {
	t.isAlive = false
}
----------------------------------------------------------------------

== The main function

If you follow the Topbeat model and put your Beat specific code in it's own type
that implements the `Beater` interface, the code from your main package becomes
very simple:

[source,go]
----------------------------------------------------------------------
func main() {

	tb := &Topbeat{}

	b := beat.NewBeat(Name, Version, tb)

	b.CommandLineSetup()

	b.LoadConfig()

	tb.Config(b)

	b.Run()

}
----------------------------------------------------------------------

